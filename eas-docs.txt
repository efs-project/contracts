(Files content cropped to 300k characters, download full ingest to see more)
================================================
FILE: README.md
================================================
# Ethereum Attestation Sevice Docs

This website is built using [Docusaurus 2](https://docusaurus.io/), a modern static website generator.

### Installation

```
$ yarn
```

### Local Development

```
$ yarn start
```

This command starts a local development server and opens up a browser window. Most changes are reflected live without having to restart the server.

### Build

```
$ yarn build
```

This command generates static content into the `build` directory and can be served using any static contents hosting service.

### Deployment

Using SSH:

```
$ USE_SSH=true yarn deploy
```

Not using SSH:

```
$ GIT_USER=<Your GitHub username> yarn deploy
```

If you are using GitHub pages for hosting, this command is a convenient way to build the website and push to the `gh-pages` branch.



================================================
FILE: babel.config.js
================================================
module.exports = {
  presets: [require.resolve('@docusaurus/core/lib/babel/preset')],
};



================================================
FILE: build.sh
================================================
#!/bin/bash

nvm use 18.12.1
yarn build
rsync -avz --delete build/ root@docs.easscan.org:/sites/eas-docs-site



================================================
FILE: docusaurus.config.js
================================================
// @ts-check
// Note: type annotations allow type checking and IDEs autocompletion

const lightCodeTheme = require('prism-react-renderer/themes/github');
const darkCodeTheme = require('prism-react-renderer/themes/dracula');
const vsDarkCodeTheme = require('prism-react-renderer/themes/vsDark');


/** @type {import('@docusaurus/types').Config} */
const config = {
  plugins: [require.resolve("@cmfcmf/docusaurus-search-local")],
  title: 'Ethereum Attestation Service',
  tagline: 'Ethereum Attestation Service is the global base layer for on/offchain generic attestations.',
  url: 'https://attest.sh',
  baseUrl: '/',
  onBrokenLinks: 'throw',
  onBrokenMarkdownLinks: 'warn',
  favicon: 'img/eas-logo.png',

  // GitHub pages deployment config.
  // If you aren't using GitHub pages, you don't need these.
  organizationName: 'Ethereum Attestation Service', // Usually your GitHub org/user name.
  projectName: 'EAS Website', // Usually your repo name.

  // Even if you don't use internalization, you can use this field to set useful
  // metadata like html lang. For example, if your site is Chinese, you may want
  // to replace "en" with "zh-Hans".
  i18n: {
    defaultLocale: 'en',
    locales: ['en', 'fr', 'zh-Hans'],
  },

  presets: [
    [
      'classic',
      /** @type {import('@docusaurus/preset-classic').Options} */
      ({
        docs: {
          sidebarPath: require.resolve('./sidebars.js'),
          // Please change this to your repo.
          // Remove this to remove the "edit this page" links.
          editUrl:
            'https://github.com/ethereum-attestation-service/eas-docs-site/blob/main/',
        },
        blog: {
          showReadingTime: true,
          // Please change this to your repo.
          // Remove this to remove the "edit this page" links.
          editUrl:
            'https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/',
        },
        theme: {
          customCss: require.resolve('./src/css/custom.css'),
        },
      }),
    ],
  ],

  themeConfig:
  /** @type {import('@docusaurus/preset-classic').ThemeConfig} */
    ({
      metadata: [
        {name: "og:image", content: "https://easscan.org/eas-summary.png"}
      ],
      navbar: {
        title: 'Ethereum Attestation Service',
        logo: {
          alt: 'EAS Logo',
          src: 'img/eas-logo.png',
        },
        items: [
          {
            href: 'https://easscan.org/',
            label: 'EAS Explorer',
            position: 'right',
          },
          {
            href: 'https://attest.sh/',
            label: 'EAS Website',
            position: 'right',
          },
          {
            href: 'https://github.com/ethereum-attestation-service',
            label: 'GitHub',
            position: 'right',
          },
        ],
      },
      footer: {
        style: 'dark',
        links: [
          {
            title: 'Docs',
            items: [
              {
                label: 'Welcome to EAS',
                to: '/docs/welcome',
              },
              {
                label: 'Learn',
                to: '/docs/category/core-concepts',
              },
              {
                label: 'Getting Started',
                to: '/docs/quick--start/quickstart',
              },
              {
                label: 'Tutorials',
                to: '/docs/category/tutorials',
              },
              {
                label: 'Developer Tools',
                to: '/docs/category/developer-tools',
              },
            ],
          },
          {
            title: 'Community',
            items: [
              {
                label: 'Twitter',
                href: 'https://twitter.com/eas_eth',
              },
              {
                label: 'Github',
                href: 'https://github.com/ethereum-attestation-service',
              },
              {
                label: 'Warpcast',
                href: 'https://warpcast.com/~/channel/eas',
              },
            ],
          },
          {
            title: 'More',
            items: [
              {
                label: 'Mirror Articles',
                to: 'https://mirror.xyz/0xeee68aECeB4A9e9f328a46c39F50d83fA0239cDF',
              },
            ],
          },
        ],
        copyright: `Copyright ¬© ${new Date().getFullYear()} Ethereum Attestation Service. Built by the Ethereum Community.`,
      },
      prism: {
        theme: lightCodeTheme,
        darkTheme: vsDarkCodeTheme,
      },
    }),
};

module.exports = config;



================================================
FILE: package.json
================================================
{
  "name": "my-website",
  "version": "0.0.0",
  "private": true,
  "scripts": {
    "docusaurus": "docusaurus",
    "start": "docusaurus start",
    "build": "docusaurus build",
    "swizzle": "docusaurus swizzle",
    "deploy": "docusaurus deploy",
    "clear": "docusaurus clear",
    "serve": "docusaurus serve",
    "write-translations": "docusaurus write-translations",
    "write-heading-ids": "docusaurus write-heading-ids"
  },
  "dependencies": {
    "@cmfcmf/docusaurus-search-local": "^1.1.0",
    "@docusaurus/core": "2.2.0",
    "@docusaurus/preset-classic": "2.2.0",
    "@mdx-js/react": "^1.6.22",
    "clsx": "^1.2.1",
    "prism-react-renderer": "^1.3.5",
    "react": "^17.0.2",
    "react-dom": "^17.0.2"
  },
  "devDependencies": {
    "@docusaurus/module-type-aliases": "2.2.0"
  },
  "browserslist": {
    "production": [
      ">0.5%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  },
  "engines": {
    "node": ">=16.14"
  }
}



================================================
FILE: sidebars.js
================================================
/**
 * Creating a sidebar enables you to:
 - create an ordered group of docs
 - render a sidebar for each doc of that group
 - provide next/previous navigation

 The sidebars can be generated from the filesystem, or explicitly defined here.

 Create as many sidebars as you want.
 */

// @ts-check

/** @type {import('@docusaurus/plugin-content-docs').SidebarsConfig} */
const sidebars = {
  // By default, Docusaurus generates a sidebar from the docs folder structure
  tutorialSidebar: [{type: 'autogenerated', dirName: '.'}],

  // But you can create a sidebar manually
  /*
  tutorialSidebar: [
    'intro',
    'hello',
    {
      type: 'category',
      label: 'Tutorial',
      items: ['tutorial-basics/create-a-document'],
    },
  ],
   */
};

module.exports = sidebars;



================================================
FILE: blog/2019-05-28-first-blog-post.md
================================================
---
slug: first-blog-post
title: First Blog Post
authors:
  name: Gao Wei
  title: Docusaurus Core Team
  url: https://github.com/wgao19
  image_url: https://github.com/wgao19.png
tags: [hola, docusaurus]
---

Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet



================================================
FILE: blog/2019-05-29-long-blog-post.md
================================================
---
slug: long-blog-post
title: Long Blog Post
authors: endi
tags: [hello, docusaurus]
---

This is the summary of a very long blog post,

Use a `<!--` `truncate` `-->` comment to limit blog post size in the list view.

<!--truncate-->

Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet

Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet

Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet

Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet

Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet

Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet

Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet

Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet

Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet

Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet

Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet

Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet

Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet

Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet

Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet

Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet



================================================
FILE: blog/2021-08-01-mdx-blog-post.mdx
================================================
---
slug: mdx-blog-post
title: MDX Blog Post
authors: [slorber]
tags: [docusaurus]
---

Blog posts support [Docusaurus Markdown features](https://docusaurus.io/docs/markdown-features), such as [MDX](https://mdxjs.com/).

:::tip

Use the power of React to create interactive blog posts.

```js
<button onClick={() => alert('button clicked!')}>Click me!</button>
```

<button onClick={() => alert('button clicked!')}>Click me!</button>

:::



================================================
FILE: blog/authors.yml
================================================
Dino:
  name: Dino Mark
  title: Co-Founder @EAS_ETH
  url: https://github.com/endiliey
  image_url: https://github.com/endiliey.png

Steve:
  name: Steve Dakh
  title: Co-Founder @EAS_ETH
  url: https://github.com/endiliey
  image_url: https://github.com/endiliey.png

endi:
  name: Endilie Yacop Sucipto
  title: Maintainer of Docusaurus
  url: https://github.com/endiliey
  image_url: https://github.com/endiliey.png

yangshun:
  name: Yangshun Tay
  title: Front End Engineer @ Facebook
  url: https://github.com/yangshun
  image_url: https://github.com/yangshun.png

slorber:
  name: S√©bastien Lorber
  title: Docusaurus maintainer
  url: https://sebastienlorber.com
  image_url: https://github.com/slorber.png



================================================
FILE: blog/2021-08-26-welcome/index.md
================================================
---
slug: welcome
title: Welcome
authors: [slorber, yangshun]
tags: [facebook, hello, docusaurus]
---

[Docusaurus blogging features](https://docusaurus.io/docs/blog) are powered by the [blog plugin](https://docusaurus.io/docs/api/plugins/@docusaurus/plugin-content-blog).

Simply add Markdown files (or folders) to the `blog` directory.

Regular blog authors can be added to `authors.yml`.

The blog post date can be extracted from filenames, such as:

- `2019-05-30-welcome.md`
- `2019-05-30-welcome/index.md`

A blog post folder can be convenient to co-locate blog post images:

![Docusaurus Plushie](./docusaurus-plushie-banner.jpeg)

The blog supports tags as well!

**And if you don't want a blog**: just delete this directory, and use `blog: false` in your Docusaurus config.



================================================
FILE: docs/welcome.md
================================================
---
sidebar_position: 1
---
# Welcome to EAS 
![EAS Banner](/img/eas-twitter-banner-v2.png)

## üëã Welcome.
**Ethereum Attestation Service (EAS)** is an open-source infrastructure public good for making attestations onchain or offchain. 

How do you decide who and what to trust? Our online and onchain worlds are filled with both genuine and deceptive information. We need a common way we can trust the authenticity of information and safety of our interactions. Anytime you need to prove or verify something, attestations will play a critical role. 

EAS is a standard and base layer where any entity can make attestations about anything. This primitive and ledger of attestations will help us decentralize more than just money and assets. We'll be able to coordinate and build reputation systems, voting systems, governance systems, decentralized social media, provenance of goods, knowledge and social graphs, and much much more. 

We're excited to see what you'll build with EAS, and we can't wait to see how you'll use attestations to create a more trustful and transparent world. 

**Read More:** [**Why We Built EAS**](/docs/purpose/eas-purpose.md)

## Why Attestations Matter
:::info
At its core, attestations are simply digital signatures on a structured pieces of information.
:::

In the age of misinformation - verifying facts, proving the authenticity and trustworthiness of information become critical. In our offline worlds, people attest to things all the time. A notary attests that you signed a document, a doctor attests to your health, a university attests to your diploma, you attest to the post and likes you make on social media, a bank attests you're qualified for a loan, and even your friends attest that they like you or that they trust you. The interactions are endless. However there is no universal and standard way for making attestations online or onchain.

At the heart of every interaction, whether it's a financial transaction or a simple online conversation, trust is essential. EAS enables anyone to make [attestations](/docs/core--concepts/attestations) onchain or offchain about anything. You simply register a schema (or use an existing one) about any topic and make attestations referencing that schema. 

We believe that by creating a free and open-source platform for attestations, we can foster innovation and enable people to verify and trust each other in a more efficient and transparent way. Join us and help build the global attestation layer for the Ethereum ecosystem.

## Key Things to Know About EAS
### ‚ú® The architecture is elegantly simple.
EAS runs on [two simple smart contracts](/docs/core--concepts/how-eas-works): one for **registering attestation Schemas** and another for **attesting with them**. Schemas can be registered for any use case, and attestations can be made onchain or offchain. You can also add a resolver contract to the Schema for advanced use cases, such as onchain verification of attestation data and attaching payments to attestations.

### üîì We don't presuppose anything.
EAS doesn't box you in with presumptions. Instead, it offers a base layer that's adaptable to myriad applications and does not make assumptions about how it will be used or the appropriate schema structure for a particular use case. It is designed to be a foundation that can be used to build more specific and complex systems on top of it and can be tailored to fit the needs of different applications. This primitive layer will enable the freedom to create and reinforce the right schemas and attestations for the right use cases for the right users over time.

### üôå  EAS is a public good.
EAS is an open-source, permissionless, tokenless, and free-to-use software. It's built by the community for the community. As a public good, we've opted for impact over profit. We realized that when you are building something so atomic for trust, it's imperative that someone with a bigger budget can't manipulate the protocol or community for their own financial gain. To become a standard, we need to keep value extractors away from value creators at the protocol layer. It must be credibly neutral. Anyone has the ability to build for-profit businesses on top of the protocol that leverages attestations.

### üí° Attestations aren't tokens.
It's a new primitive. While tokens represent a type of digital asset, EAS attestations are fundamentally different. The primary purpose of EAS is to serve as a protocol that facilitates the creation of digital signatures on structured information, enhancing both their composability and interoperability, trust, and validation. You can build your own UIs for attestation data or even generate NFTs or different ERCs based on attestations.

### üß† Think beyond identity.
The identity ecosystem is extremely fragmented and a key reason why EAS was built, however, its flexibility lends itself to build trust beyond identity. EAS is not an identity provider. EAS allows for a wide range of possibilities for entrepreneurs and developers to build applications that make use of attestations. Some examples of what can be built with EAS include reputation systems, provenance of information or assets, voting & governance systems, registries, social graphs, and more. We're excited to see what you'll build with EAS and how you'll use attestations to create a more trustful and transparent world.

Get inspired with a few [**thought starters!**](/docs/idea--zone/thought-starters.md) 

## Start Building
We're excited to see what you build with EAS. Let's get started!

1. Read the documentation to [**learn more about attestations**](https://docs.attest.org/docs/category/core-concepts) and how to use EAS.
2. [**Install the SDK**](https://docs.attest.org/docs/developer-tools/eas-sdk) to easily integrate into a Javascript/Typescript project 
3. Create your own [**indexer**](https://github.com/ethereum-attestation-service/eas-indexing-service) for easily indexing attestation data.
4. Query your attestations with the [**GraphQL API**](/docs/developer-tools/api) using the EAS smart contracts or UI.
5. Use the EAS Explorer to [**create and verify attestations**](https://easscan.org/attestations) for any purpose.

## Join the Community
Come build with us. EAS is built by the community and for the community. You can join the community and contribute to the project by:

1. Joining the EAS telegram channel for discussions and support [**EAS Telegram**](https://t.me/+EcynOr0iFu03MTYx).
2. Submitting issues or pull requests on the [**EAS GitHub**](https://github.com/ethereum-attestation-service) repository.
3. Following for updates and announcements on X (Twitter) [**@eas_eth**](https://twitter.com/eas_eth).





================================================
FILE: docs/core--concepts/_category_.json
================================================
{
  "label": "Core Concepts",
  "position": 4,
  "link": {
    "type": "generated-index",
    "description": "Learn the fundamental concepts about attestations and EAS."
  }
}



================================================
FILE: docs/core--concepts/attestations-vs-x.md
================================================
---
sidebar_position: 6
---

# Attestations vs X
Navigating the Ethereum ecosystem can sometimes feel like deciphering a bowl of alphabet soup. This page aims to demystify some of the prevalent terms and guide you in making informed decisions.

## What are Attestations?
At their essence, attestations are cryptographically signed statements or pieces of evidence. They act as digital records, verifying information about an individual, entity, or event. In a world where trust is digital, attestations are foundational.

## Understanding Common Terms
- **Attestations:** These are your digital trust anchors. Versatile and designed for composability and interoperability, they can vouch for a multitude of information types.
- **NFTs (Non-Fungible Tokens):** Digital collectibles. Unique and transferable, they're ideal for representing distinct assets like art or collectibles.
- **Soulbound Tokens (SBTs):** Essentially, these are non-transferable NFTs. They've gained traction for representing facets of identity, but in essence, they're just non-transferrable attestations without any structure to them. 
- **Verifiable Credentials:** Often linked to the W3C standard, they offer a structured approach to credentials. However, they aren't as adaptable as attestations and weren't primarily designed for blockchain ecosystems.
- **Decentralized Identifiers (DIDs):** These are unique digital identifiers. While essential, they're just a part of the identity puzzle. Your Ethereum wallet address, for instance, is a DID, but it's not your entire identity.
- **Claims:** These are statements awaiting validation and often don't have the authenticity of a digital signature.
- **Proofs:** Mathematical validations confirming the authenticity of a request or claim.
- **Badges:** Digital symbols or emblems. They're attestations of achievements or affiliations. While popular, badges have inherent risks of transferability and no standardization contributing to more fragmentation. 

## Attestations: Beyond Just Identity
Attestations are versatile. While they can vouch for identity facets, their utility extends beyond. They can represent events, validate claims, and more. Their composability allows for nuanced use cases, like linking identity attributes with event participation. 

## Think Critically About Your Project
- **Bias Check:** Are you leaning towards a particular solution because it's the "hot" thing right now, or does it genuinely fit your project's needs?
- **Purpose:** What are you trying to achieve? If you're looking to represent a unique piece of digital art, an NFT might be the way to go. But if you're trying to vouch for a user's identity or a specific claim, an attestation could be more apt.
- **Flexibility:** Do you need a tool that's versatile and can represent a broad range of information? Attestations offer a level of flexibility that's hard to match.
- **Interoperability:** If your project spans across multiple platforms or dapps, consider how easy it will be to integrate your chosen solution across these platforms.
- **Future-Proofing:** The Ethereum ecosystem is rapidly evolving. Think about how your chosen solution might adapt to future changes or needs.

## Wrapping Up
Attestations offer a robust and versatile solution for a myriad of use cases in the Ethereum ecosystem. They're not just about identity; they're about trust, validation, and composability. While NFTs and SBTs have their merits, especially when representing unique assets, they may not be the best fit for more intricate and nuanced scenarios. As a builder, it's essential to step back and critically evaluate the tools at your disposal. Remember, the goal is to build solutions that are not only innovative but also sustainable and adaptable to the ever-evolving landscape of the blockchain world.



================================================
FILE: docs/core--concepts/attestations.md
================================================
---
sidebar_position: 2
---

# Attestations

:::info What are attestations?
**Attestations** /ÀåaÀåteÀàstƒÅSH(…ô)n; are structured pieces of information signed by an entity about something. 
:::

At its core, an attestation is a digital signature on structured data. Think of it as a digital stamp of approval or verification. It's a way for one entity (the attester) to make a claim about another entity or about some data. This claim is then cryptographically signed to ensure its authenticity and immutability. With EAS, attestations can be made onchain or offchain.

## Why Attestations Matter
Attestations are crucial because they offer a means of establishing trust and credibility online. In the
absence of face-to-face interaction or physical presence, it can be challenging to determine the accuracy or reliability
of information. Attestations provide third-party validation and a cryptographically signed confirmation of the
authenticity of a piece of information, making it easier for others to trust and depend on that information.

The **credibility** of an attestation hinges on the reputation of the entity making it. For instance, a credit score attestation holds weight when issued by a recognized credit bureau, but not so much if declared by an individual.

üìò **Read more:** [**Why We Built EAS**](/docs/purpose/eas-purpose.md)


## When to use Attestations
Attestations serve as a bridge between the digital and physical worlds, providing a mechanism to verify and validate claims in various scenarios. Here's a more comprehensive look at when attestations can be invaluable:

- **Verifying:** Confirming the authenticity of a product or the accuracy of information.
- **Vouching:** Endorsing someone's skills, experience, or character.
- **Voting:** Recording preferences or decisions in elections or community polls.
- **Proving:** Demonstrating ownership of assets, completion of tasks, or attainment of milestones.
- **Authenticating:** Establishing the genuineness of an item, artwork, or collectible.
- **Certifying:** Validating completion of courses, training, or adherence to standards.
- **Endorsing:** Publicly supporting or recommending a product, service, or individual.
- **Validating:** Confirming the legitimacy of a claim, be it health records, financial status, or any other data.
- **Recording:** Keeping a digital note of events, achievements, or incidents.
- **Witnessing:** Attesting to the occurrence of an event, action, or decision.
- **Guaranteeing:** Assuring the quality, durability, or performance of a product or service.
- **Declaring:** Making a formal or official statement about a fact, intention, or belief.
- **Confirming:** Corroborating an event, transaction, or activity.
- **Securing:** Ensuring the safety, privacy, or confidentiality of data or actions.
- **Identifying:** Establishing the identity or characteristics of an individual, organization, or item.

## Attestation Example
Below is an example onchain attestation record. It's from one address (0x1d86...1EA3F0) attesting a message to vitalik.eth saying "GM".

![Attestations Concept](./img/example-attestation.png)

1. **Every attestation is unique:** Each attestation has its own unique identifier (UID) which is a hash of the entire attestation
2. **Know the current status of the attestation:** Verify the current status of the attestation to see when it was created, if it has expired, or if the attester has revoked it. This can help you determine if the attestation is still valid and trustworthy, ensuring you have the most up-to-date information.
3. **Every attestation follows a schema:** Schemas are the data of the attestation. They are completely customizable and can be created for any purpose, allowing users to leverage preexisting schemas or create new ones tailored to their specific needs.
4. **Know who is involved**: Find out which address made the attestation and if there is a recipient involved. Knowing who is involved in the attestation is important to understand the context and trustworthiness of the information being attested to.
5. **Get a clear view of the attestation data:** The attestation data will be decoded in this section based on the schema used so that it is easily legible for any verifiers or users inspecting the attestation content.
6. **Build composable attestations:** One of the most powerful features of EAS is its ability to allow attestations to reference other attestation UIDs. This makes it possible to organize attestations in a more structured manner and understand their relationships easily.

## How Attestations are Made
Creating an attestation is a straightforward process, but it's underpinned by robust cryptographic principles:

1. **Define the Data:** Before making an attestation, you need to know what you're attesting to. This is where the schema comes into play. Either select a pre-existing schema or create a new one that defines the structure of your data.

2. **Sign the Data:** The issuer (or attester) then signs this structured data using their private key. This signature is a cryptographic seal of approval, ensuring the data hasn't been tampered with.

3. **Store the Attestation:** Once signed, the attestation is stored. With EAS, this can be on the blockchain (onchain) or off the blockchain (offchain).

4. **Verification:** Post creation, anyone can verify the attestation if made available to them. They can check the digital signature against the issuer's public key, ensuring the attestation's authenticity.

5. **Lifecycle Management:** Over time, the status of an attestation might change. While it can't be edited due to its immutability, it can be revoked if the information is no longer valid. This revocation is also stored, ensuring a clear history of the attestation's lifecycle.

6. **Referencing & Building:** One of EAS's powerful features is the ability to reference other attestations. This allows for the creation of a web of interconnected attestations, each adding context and depth to the others.

## Tools to Start Building
To dive deeper into the world of attestations and begin crafting your own, explore the EAS platform. We offer a range of tools and resources, from a no-code schema builder to SDKs, that make the process intuitive and efficient. Join the EAS community and be a part of the movement in digital trust and verification.

- [**SDK**](/docs/developer-tools/eas-sdk.md)
- [**GraphQL API**](/docs/developer-tools/api.md)
- [**Tutorials**](/docs/category/tutorials)




















================================================
FILE: docs/core--concepts/composability.md
================================================
---
sidebar_position: 7     
---

# Composability
Composability in the blockchain world is akin to building with LEGO bricks. Each piece, or in this case, each attestation, can stand alone, but when combined, they form a more complex and intricate structure. Let's dive into how this works with attestations.

## What is Composability?
Composability is the art and science of assembling smaller components to create a more complex system. In the context of blockchain and attestations, it's about ensuring that individual attestations, or data points, can be seamlessly combined or referenced to form a cohesive narrative or dataset. This modular approach not only enhances the flexibility of data structures but also ensures that data remains interconnected, traceable, and verifiable.

## Referenced Attestations: The Key
The `refUID` (referenced attestation unique identifier) feature in attestations is the core building block of composability. It allows an attestation to reference another, weaving a tapestry of interconnected attestations. This interconnectedness ensures that each attestation can either add depth, context, or validation to another.

## Example: Decentralized Social Media
Imagine a decentralized social media platform. You post a message, and that action creates an attestation. When someone comments or likes your post, they're not just interacting with a UI; they're creating a new attestation that references your original one via its `UID`. 

Here's an example social media post on Sepolia from `timbeiko.eth` saying "GM!". Notice that there are two likes and a reply?
![Sample Post](./img/sample-post.png)

:::info These are just attestations! 
:::

Each post, each reply, and each like are just attestations referencing each other. Here is that same post on Sepolia with the onchain attestation record. Notice the `uid` of the Onchain attestation record? That is being used as a reference for the additional attestations made for liking and replying. At the bottom of the image you will see a new schema being used for `Like an Entity` and the same schema of `Post` being used.

[**See this Attestation on Sepolia**](https://sepolia.easscan.org/attestation/view/0x36e12bac4f9de35e831757dcdfbbd7301cbedd521eb11b83332cb439ed4da31b)

![Sample RefUID](./img/sample-refUID.png)

## Building with Composability in Mind
- **Think Modular:** Design each schema to be self-contained but ready to connect with others.
- **Use refUID Effectively:** It's a simple tool, but it's the bridge between attestations.
- **Keep Users Informed:** Make sure users understand how their data is being used and connected.

## Wrapping Up
Composability is about seeing the potential in simple components and understanding how they can come together to create something more significant. With attestations, this means a more flexible, modular, scalable, and transparent system.


================================================
FILE: docs/core--concepts/credible-neutrality.md
================================================
---
sidebar_position: 10
---

# Credible Neutrality
In an era where biases and hidden agendas often skew digital platforms, the principle of "Credible Neutrality" stands as a testament to genuine fairness and trustworthiness. It's a foundational requirement for systems that aim to earn unwavering trust.

## What is Credible Neutrality?
`Credible Neutrality` is the commitment of a system to operate without favoring any participant, agenda, or outcome. It's a promise that the platform's operations are transparent, unbiased, and free from external influences. Email is a great example and mental model of a protocol that is credibly neutral. You know that email won't be captured by some for-profit entity. Anyone can build on it and use it for their own purposes.

## Why It Matters
Consider a world where every digital interaction is tinged with doubt. Is this person real? Is this platform suppressing certain voices? What happens if I click this link? Credible Neutrality makes things a bit more:

- **Trustful:** Users can confidently interact with systems, knowing there are no hidden agendas or rent extraction.
- **Fair:** A neutral platform ensures everyone has an equal opportunity, fostering genuine innovation.
- **Resilient:** Systems built on neutrality are robust against manipulation, ensuring reliability.

## EAS Embodies Credible Neutrality
EAS provides a platform that doesn't play favorites. Every attestation, every interaction, is treated with the same level of impartiality. The code has been refactored so many times to not presuppose how it will be used or who will use it, giving everyone a fair shot to build amazing things on top of it.

Credible Neutrality is a core strength required in becoming a standard. Anyone can copy open-source code, but it's the community's trust in its neutrality that makes it unique and irreplaceable.

## Centralization & Tokens != Credible Neutrality
### Centralization: The Single Point of Bias
Centralization, by its very nature, concentrates power and control within a single entity or a select group. This concentration introduces:
- **Potential for Bias:** A centralized authority can, intentionally or unintentionally, favor certain participants or outcomes over others.
- **Opaque Decisions:** With centralized control, it's challenging to ensure that decisions are made transparently and for the collective good.
- **Vulnerability:** Centralized systems can become single points of failure, both technically and ethically.

### Tokens: The Double-Edged Sword
While tokens can incentivize participation and growth in a platform, they can also introduce challenges:

- **Profit over Purpose:** The drive to increase a token's value can overshadow the platform's primary purpose, leading to decisions that prioritize profit over neutrality.
- **Unintended Barriers:** Token-based systems can inadvertently create barriers to entry, where only those holding or willing to invest in the token can fully participate.
- **Speculation Over Utility:** The focus can shift from the platform's utility to the speculative value of the token, detracting from the platform's core mission.

## Wrapping Up
Credible Neutrality is a necessity for digital systems aiming for genuine trust. EAS, rooted in this principle, ensures its position as a trusted entity in the attestation landscape. 



================================================
FILE: docs/core--concepts/delegated-attestations.md
================================================
---
sidebar_position: 9
---

# Delegating
Delegated Attestations enable an entity to sign an attestation while allowing another entity to cover the transaction
fee.

:::tip Delegator = Attester
When an attestation is delegated, the delegator (signer) address is the address that shows up as the attester on the attestation.
:::

## Use Cases

When using delegated attestations on EAS, the actual attester and the one covering the transaction fee can be two
different entities, allowing for various use cases. It's particularly useful when:

- A service wants to pay for its users' attestations (covering gas costs)
- An entity wants to make multiple attestations but allows the recipient or another party to pay for the transaction
  fees for it to go on-chain.

## How they work

In the [**EAS SDK**](https://github.com/ethereum-attestation-service/eas-sdk?tab=readme-ov-file#example-creating-delegated-onchain-attestations), you'll find code examples of how to create and revoke delegated attestations.

```jsx
//Example: Creating Delegated Onchain Attestations 

import { EAS, SchemaEncoder } from '@ethereum-attestation-service/eas-sdk';

const eas = new EAS(EASContractAddress);

// Use a different account to send and pay for the attestation.
eas.connect(sender);

const delegated = await eas.getDelegated();

// Initialize SchemaEncoder with the schema string
// Note these values are sample values and should be filled with actual values
// Code samples can be found when viewing each schema on easscan.org
const schemaEncoder = new SchemaEncoder('uint256 eventId, uint8 voteIndex');
const encodedData = schemaEncoder.encodeData([
  { name: 'eventId', value: 1, type: 'uint256' },
  { name: 'voteIndex', value: 1, type: 'uint8' }
]);

const signer = new ethers.Wallet(privateKey, provider);

// Please note that if nonce isn't provided explicitly, we will try retrieving it onchain.
const response = await delegated.signDelegatedAttestation(
  {
    schema: '0xb16fa048b0d597f5a821747eba64efa4762ee5143e9a80600d0005386edfc995',
    recipient: '0xFD50b031E778fAb33DfD2Fc3Ca66a1EeF0652165',
    expirationTime: 0n, // Unix timestamp of when attestation expires (0 for no expiration)
    revocable: true,
    refUID: '0x0000000000000000000000000000000000000000000000000000000000000000',
    data: encodedData,
    deadline: 0n, // Unix timestamp of when signature expires (0 for no expiration)
    value: 0n
  },
  signer
);

const transaction = await eas.attestByDelegation({
  schema: '0xb16fa048b0d597f5a821747eba64efa4762ee5143e9a80600d0005386edfc995',
  data: {
    recipient: '0xFD50b031E778fAb33DfD2Fc3Ca66a1EeF0652165',
    expirationTime: 0n, // Unix timestamp of when attestation expires (0 for no expiration),
    revocable: true,
    refUID: '0x0000000000000000000000000000000000000000000000000000000000000000',
    data: encodedData
  },
  signature: response.signature,
  attester: await signer.getAddress(),
  deadline: 0n // Unix timestamp of when signature expires (0 for no expiration)
});

const newAttestationUID = await transaction.wait();

console.log('New attestation UID:', newAttestationUID);

console.log('Transaction receipt:', transaction.receipt);

```

## Supercharged Delegated Attestations with Proxy Contracts

Standard delegated attestations require an incrementing nonce based on the EIP-712 spec, but the proxy contract allows
you to accept delegated attestations out of order and with an expiration time. This is particularly useful when you have
a single entity like a KYC provider attesting to many users while wanting the users to pay for the gas. See the below
example proxy contract for more details.

:::tip **Example Permissioned EIP712 Proxy Contract:**
https://github.com/ethereum-attestation-service/eas-contracts/blob/master/contracts/eip712/proxy/examples/PermissionedEIP712Proxy.sol
:::




================================================
FILE: docs/core--concepts/how-eas-works.md
================================================
---
sidebar_position: 1
---

# How EAS Works
At its core, EAS revolves around two primary contracts: registering a schema and making attestations. But what does that mean? Let's break it down.

![EASArchitecture](./img/schema-attestation.png)


## The Foundation: Attestations
Attestations are the building blocks of building trust online. Think of an attestation as a digital stamp of approval on a piece of data. It's a way for one entity to say, "I vouch for this information." and gives others the optionality to rely on that information.

But for this system to work seamlessly, we need a standardized way to structure this data. This is where schemas come into play.

## Schemas give structure to the attestation
Think of a schema as a blueprint or template. It defines the structure and format of the data you want to attest to. For example if you want to attest to someone you trust, all you'd need is a true false field for "isTrusted". Or if you wanted to a vote, you might have a "eventName" and a "location" and "startTime" and "endTime". It's the builder's choice to determine the right schema for their particular use case.

Here's the general flow of how a schema is registered:
1. The schema's structure is defined (e.g., what fields it will have and the data types).
2. The schema is submitted to the Schema Registry Contract.
3. The contract assigns a unique identifier (UID) to the schema so it can be easily referenced.
4. The schema is now ready to be used for attestations!

```javascript
/// @notice A struct representing a record for a submitted schema.
struct SchemaRecord {
    bytes32 uid; // The unique identifier of the schema.
    ISchemaResolver resolver; // Optional schema resolver.
    bool revocable; // Whether the schema allows revocations explicitly.
    string schema; // Custom specification of the schema (e.g., an ABI).
}
```
Before you rush to create a new schema, it's worth checking the schemas already registered on the [Explorer](https://easscan.org/schemas). The community often contributes schemas, making it a rich resource. If you find one that fits your needs, great! If not, you can design a new one.

üéì **Tutorial**: [**Make a Schema**](/docs/tutorials/create-a-schema.md)

## Making an Attestation
Once you've settled on a schema, the process of making an attestation is straightforward:

1. The data being attested to is structured according to a specific schema.
2. This structured data is signed by the attester, creating a digital signature either onchain or offchain.
3. The signed data, along with the schema's unique identifier, is submitted to the Attestation Contract
4. The contract verifies the data against the schema and stores the attestation.
5. The attestation is now recorded on the blockchain and can be verified by anyone!

```javascript
/// @notice A struct representing the arguments of the attestation request.
struct AttestationRequestData {
    address recipient; // The recipient of the attestation.
    uint64 expirationTime; // The time when the attestation expires (Unix timestamp).
    bool revocable; // Whether the attestation is revocable.
    bytes32 refUID; // The UID of the related attestation.
    bytes data; // Custom attestation data.
    uint256 value; // An explicit ETH amount to send to the resolver. This is important to prevent accidental user errors.
}
```
The beauty of EAS is its flexibility. You can reference previous attestations, creating a network of interconnected data points to give more context to each attestation. And if ever there's a need to update or invalidate an attestation, it can be revoked. While the original record remains, its status changes, ensuring transparency and trust.

üéì **Tutorial**: [**Make an Attestation**](/docs/tutorials/make-an-attestation.md)

## Diving Deeper: The Technical Side
For those keen on the technical details:

- [**Schema Registry Contract:**](https://github.com/ethereum-attestation-service/eas-contracts/blob/master/contracts/SchemaRegistry.sol) This is how schemas are registered.
- [**Attestation Contract:**](https://github.com/ethereum-attestation-service/eas-contracts/blob/master/contracts/EAS.sol) This contract manages the lifecycle of attestations, from creation to potential revocation.

## Wrapping Up
EAS is more than just a service; it's a new primitive in how we establish and manage trust online. Its simplicity and flexibility make it a powerful tool for a myriad of applications.

If you're eager to explore further, our documentation is filled with deeper dives into each aspect of EAS. Whether you're here to build or to learn, we're thrilled to have you on this journey with us.



================================================
FILE: docs/core--concepts/onchain-vs-offchain.md
================================================
---
sidebar_position: 5
---

# Onchain vs Offchain
Attestations can be made either onchain or offchain. While **onchain attestations** are stored directly on the Ethereum blockchain, **offchain attestations** reside outside of it, often in decentralized storage solutions like IPFS or even as URL hashes in browsers. Both methods have their unique advantages, and the choice largely depends on the specific requirements of the use case.

![Onchain vs Offchain](./img/on-off-v1.png)

## What are Onchain and Offchain Attestations?
- **Onchain Attestations:** These are attestations that are stored directly on the Ethereum blockchain. They are immutable and benefit from the security and decentralization of the blockchain. They are great when attestations need to be read by smart contracts or you need guaranteed availability.

- **Offchain Attestations:** These attestations are stored off the Ethereum blockchain, typically in a database or another storage mechanism. They are linked to the blockchain through cryptographic signatures but do not reside on it. Offchain attestations are great when you want to hold the attestation privately and shared on a need to know basis.

## Onchain vs Offchain: At a Glance
| Feature/Aspect                  | Onchain Attestations                                      | Offchain Attestations                                       |
|--------------------------------|----------------------------------------------------------|-------------------------------------------------------------|
| **Authenticity**                | Has the authenticity of a digital signature               | Has the authenticity of a digital signature                 |
| **Interoperability**            | Easily read by smart contracts                            | Requires additional steps for smart contracts               |
| **Storage Location**            | Directly on the blockchain                                | Anywhere you want: Centralized servers, decentralized storage (e.g., IPFS), or browser URL hashes |
| **Visibility**                  | Publicly accessible                                       | Can be public or private                                    |
| **Privacy**                     | Data is public but can be made secure with encryption/ZKPs and other methods | More control over data visibility                           |
| **Cost**                        | Ethereum gas fees, cheaper on L2s                         | Zero gas fees                                               |
| **Immutability**                | Once stored, cannot be altered                            | Data is cryptographically secure but can be deleted if stored off the blockchain |
| **Verification**                | Directly verifiable on the blockchain                     | Requires additional verification steps                      |
| **Security**                    | Secured by blockchain consensus                           | Secured by cryptographic signatures                         |
| **Scalability & Performance**   | Requires onchain transactions to process                  | Faster processing times; can lead to better scalability     |
| **Timestamping**                | Inherent timestamping by the blockchain                   | The UID of the attestation can be timestamped onchain for verifiability |
| **Lifecycle Management**        | Revocations stored onchain                                | Revocations require need separate management                  |


## Best Practices
### Onchain Attestations
- **Minimize Data:** Due to cost implications, store minimal data onchain. Consider storing only hashes or references to offchain data. Build in modular ways.
- **Privacy First:** If you must store sensitive data onchain, ensure it's encrypted or hashed. Use privacy best practices.
- **Plan for Gas Fees:** Be aware of potential gas fees, especially during network congestion. Consider layer 2 solutions for reduced fees.

### Offchain Attestations
- **Secure Storage:** Ensure the storage solution, whether centralized or decentralized, is secure and reliable.
- **Data Redundancy:** Store data in multiple locations or use decentralized storage for added redundancy.
- **Easy Retrieval:** Ensure that offchain attestations can be easily retrieved and verified when needed.
- **Timestamp Offchain Onchain:** Timestamp the UID of the offchain attestation onchain to give it a verifiable proof of existence.

## Privacy Considerations
It's important for builders to consider what data needs to go onchain or should live offchain. A common misconception with onchain attestations is that they do not have privacy features. There are several ways to keep onchain attestation data more private. 

- **Offchain:** Generally preferable for confidentiality as no data is publicly visible unless explicitly stored in places like IPFS.
- **Private Data Attestations:** An innovative solution to attest nearly an infinite amount of private data by attesting its [merkle root onchain](/docs/tutorials/private-data-attestations.md).
- **Onchain Adaptations:** Rather than placing the entire data on why something was true, one could attest to results, such as a true/false field of the verification. 
- **Leverage ZKP:** Generate a zero-knowledge proof from the attestation data to keep information private and trustworthy. 
- **Bottom Line:** Prioritize privacy. Whether you're storing a verification process or the verification result, sensitive data management is paramount.


## Making the Right Choice: Onchain vs. Offchain
Navigating the world of attestations might seem complex, but it boils down to understanding your project's needs and making informed choices. Here's a pragmatic guide to help you decide:

- **Authenticity is a Given:** Both onchain and offchain attestations offer the authenticity of a digital signature. No matter where it's stored, if the data changes, the signature won't verify.
- **Smart Contract Interaction:** If your project requires smart contracts to frequently access or verify attestation data, onchain is your best bet. It ensures that the data is always available on the Ethereum blockchain for smart contracts to interact with.
- **Privacy Matters:** If you're handling sensitive data or want to control who sees what and when, offchain offers more flexibility. Store data privately and share it selectively. But remember, onchain isn't out of the race for privacy. With techniques like private data attestations, you can store a merkle root onchain and then selectively disclose specific parts of your data when needed.

In short, think about how your data will be used. If it's crucial for smart contracts, onchain might be the way. If it's about privacy and controlled sharing, offchain could be your answer. And sometimes, a blend of both might be the perfect solution. The power to choose is yours.

## Verifiable Data Ledger - a Third Option

Some projects may require the scalability and cost efficiencies that coincide with off-chain attestations in addition to the added security and ease-of-verifiability benefits tied to on-chain transactions. Especially when dealing with a high volume of attestations (or relevant data more generally) at scale, engineering teams often find themselves unnecessarily giving up qualities like global consensus, immutability, and transparency in favor of faster performance and lower cost.

There are, however, additional storage options designed to maximize on both scalability and decentralization, offering a less binary solution suitable for many use-cases, including off-chain attestations. For example, options like the Ceramic Network offer data-streaming and querying capabilities familiar to developers who have worked with Kafka, GraphQL, and relational databases, but built on a fully decentralized and open-source framework built on IPFS content addressing with "roll-up" publishing transactions directly on the Ethereum blockchain. *Learn how to store and retrieve off-chain attestations on Ceramic using ComposeDB in [this tutorial](../tutorials/ceramic-storage).*

It's important for teams to consider the trade-offs between on-chain, off-chain, and non-conforming solutions like Verifiable Data Ledgers, and make the design choices best suited for their unique goals and use-cases. 


================================================
FILE: docs/core--concepts/privacy.md
================================================
---
sidebar_position: 6
---

# Privacy

In the age of digital transformation, privacy is paramount. When building with attestations, it's essential to prioritize privacy to protect users and maintain trust. This page delves into how to think about and implement privacy-first solutions using attestations.

![Privacy](./img/privacy-face.png)

## A Privacy-First Mindset
The blockchain's defining feature of immutability is a double-edged sword. While it ensures data integrity, it also means that once data is onchain, it's permanent. This permanence underscores the importance of handling personal or sensitive data with extreme caution.

## Strategies for Privacy-First Attestations
Below are a few concepts to consider when building with privacy in mind.

### Private Data Attestations
Private Data Attestations are a way to attest to nearly an infinite amount of arbitrary data, generate a merkle tree of that data, and then only attest to the merkle root onchain or offchain. The data can then be provided to specific individuals and allow them to selectively disclose or verify the data against the merkle root. 

For example, a university could attest to a student's entire transcript by creating a merkle tree of the courses and grades, and then only attesting to the root onchain. The student can then provide specific courses to employers without revealing their entire transcript.

**üìò Read More:** [**Private Data Attestations**](/docs/tutorials/private-data-attestations.md)

### Offchain Attestations
Create attestations completely offchain, allowing for selective disclosure on a need-to-know basis while still benefiting from the authenticity of the digital signature. Below is an example of an offchain attestation. It's completely private, the easscan.org server doesn't even know it exists. The data is completely encoded in the URI fragment of the URL and can be passed peer-to-peer through the browser or stored anywhere the creator would like.

![Example offchain attestation](./img/offchain-example.png)

**Link to the Example Offchain Attestation on Sepolia:**
[https://sepolia.easscan.org/offchain/url/#attestation=eNqlUUluHDEM%2FEufB4a4k0fPjOcTQQ5aqAcECeDnh93xBwLzUKBYVFEs%2FTjaG%2BpxAwCRgtvRPh%2BoFvv%2BJFvC5P5IDnrB825C2J5ImuAgeZzNBmHLaXVRcRudgQfAImqpgMQ2%2B5w5R99N2trZaCGLMUPiVJiXSJOYROI%2BZfnW3BO7V7JcNmxjcVzWVcB1dszsnEQ7JqyxEdyOG9qpk5nq%2FeORd36PjE3onXVSvGq2035vSDGfr2uodyluiw7aEKFWa3OjQSbcsgEL4xwUAqZdFbgFjVYedIux8N%2FLKTRGVbXPPSKwb%2BElgMZTpqsrw%2BxCzAm9z9UGbEne3vpsjrhPkXJfgwHYXG7tKvz%2B9ScvY74V%2BL3rjcuJWiGsvv0LQbNw6xlUXL38qoCxsYpRYeVVrW%2FEYi4FwWZULJqeWP1cfHVXjxnXWU7mUhqaus2uWViZXHwUwv9vcJSf8PMv1OWspA%3D%3D](https://sepolia.easscan.org/offchain/url/#attestation=eNqlUUluHDEM%2FEufB4a4k0fPjOcTQQ5aqAcECeDnh93xBwLzUKBYVFEs%2FTjaG%2BpxAwCRgtvRPh%2BoFvv%2BJFvC5P5IDnrB825C2J5ImuAgeZzNBmHLaXVRcRudgQfAImqpgMQ2%2B5w5R99N2trZaCGLMUPiVJiXSJOYROI%2BZfnW3BO7V7JcNmxjcVzWVcB1dszsnEQ7JqyxEdyOG9qpk5nq%2FeORd36PjE3onXVSvGq2035vSDGfr2uodyluiw7aEKFWa3OjQSbcsgEL4xwUAqZdFbgFjVYedIux8N%2FLKTRGVbXPPSKwb%2BElgMZTpqsrw%2BxCzAm9z9UGbEne3vpsjrhPkXJfgwHYXG7tKvz%2B9ScvY74V%2BL3rjcuJWiGsvv0LQbNw6xlUXL38qoCxsYpRYeVVrW%2FEYi4FwWZULJqeWP1cfHVXjxnXWU7mUhqaus2uWViZXHwUwv9vcJSf8PMv1OWspA%3D%3D)

**üìò Read More:** [**Offchain Attestations**](/docs/tutorials/private-data-attestations.md)

### Offchain Computations
Perform computations offchain and attest to the results onchain. This method ensures that raw data remains private, but the computation's outcome can still be verified. For example, a platform could verify a user's age offchain and then only attest to whether the user is over 18 on-chain, without revealing the exact birthdate, or even that the verification had to do with a birthdate.

### Encryption & Hashing
Always encrypt sensitive data, even if it's offchain. When attesting to encrypted data, ensure that only authorized parties have the decryption keys. For example, if you're storing a user's educational credentials, encrypt the attestation data offchain. When a third party needs to verify it, they can be given a decryption key to access the specific data they need. 


### Zero Knowledge Proofs (ZKPs)
ZKPs allow one party to prove to another that a statement is true without revealing any specific information about the statement itself. It's a powerful tool for privacy-preserving attestations. For example, you can generate an attestation onchain or offchain and then allow the recipient or issuer of the attestation generate an ZKP from the attestation data. Which then can be selectively shared to those who need to know without disclosing the addresses or data involved.




## Best Practices

1. **Avoid Onchain Personal Data:** Never attest to personal or private data directly on-chain. Always use hashes or other privacy-preserving methods.
2. **Educate Users:** Ensure users understand what data is being attested to and how it will be used.
3. **Regularly Review Privacy Practices:** As technology evolves, so do privacy concerns. Regularly review and update your practices to stay ahead.

## Wrapping Up

Privacy isn't just a feature; it's a right. As builders, it's our responsibility to ensure that we're not only leveraging the power of blockchain and attestations but doing so in a way that respects and prioritizes user privacy. With a privacy-first mindset, we can create solutions that are both powerful and trustworthy.




================================================
FILE: docs/core--concepts/resolver-contracts.md
================================================
---
sidebar_position: 8 
---

# Resolver Contracts
Resolver Contracts are a powerful tool that allows developers to introduce custom logic to their schemas. Think of them as gatekeepers or hooks, ensuring that attestations meet specific criteria before they're accepted. Let's delve into the concept, its workings, and some practical examples.

## What's a Resolver Contract?
A `Resolver Contract` is essentially an external smart contract that acts as a hook for a Schema. It ensures that attestations adhere to certain rules or conditions before they're finalized. This allows developers to extend the functionality of a schema, be it restricting attestations to a certain group, integrating payment mechanisms, or even minting NFTs under specific conditions.

## How Do Resolver Contracts Work?
When you create a schema, you might want it to follow certain rules or behaviors. This is where resolver contracts come into play. When attaching a resolver contract to a schema, you can ensure that the schema behaves according to the logic defined in the resolver contract.

For those who want a deeper dive, the [**resolver repository**](https://github.com/ethereum-attestation-service/eas-contracts/tree/master/contracts/resolver) in the EAS GitHub Repository serves as a foundational contract for creating custom resolver contracts. It provides the necessary framework to validate and process attestations in a modular manner.

**üéì Tutorial:** [**Resolver Contracts**](/docs/tutorials/resolver-contracts.md)

:::caution Important Note
Resolver Contracts are external contracts to EAS. 

EAS does not verify, endorse, or audit the resolver's people create and set on schemas. Do your own due diligence and do not interact with resolver contracts you are not familiar with.
:::

## Practical Examples
While the possibilities are vast, here are some example resolver contracts to give you an idea:

| Resolver Name            | Description                                                                                                   | Example                                                                                                       |
|--------------------------|---------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------|
| **Attester Resolver**    | This resolver ensures that an attestation is created by a specific attester. It's like a VIP pass, where only a particular entity is allowed to attest. | [AttesterResolver.sol](https://github.com/ethereum-attestation-service/eas-contracts/blob/master/contracts/resolver/examples/AttesterResolver.sol) |
| **Expiration Time Resolver** | This resolver checks if an attestation's expiration time meets a certain condition. Think of it as a "best before" date for attestations. | [ExpirationTimeResolver.sol](https://github.com/ethereum-attestation-service/eas-contracts/blob/master/contracts/resolver/examples/ExpirationTimeResolver.sol) |
| **Paying Resolver**      | This resolver facilitates payments to attesters when they create an attestation. It's a way to incentivize or reward certain attestations. | [PayingResolver.sol](https://github.com/ethereum-attestation-service/eas-contracts/blob/master/contracts/resolver/examples/PayingResolver.sol) |
| **Recipient Resolver**   | Ensures an attestation is made to a specific recipient. It's like sending a letter, where only the intended recipient should receive it. | [RecipientResolver.sol](https://github.com/ethereum-attestation-service/eas-contracts/blob/master/contracts/resolver/examples/RecipientResolver.sol) |
| **Revocation Resolver**  | Provides control over revocations of attestations. It's a way to manage and control the revocation process. | [RevocationResolver.sol](https://github.com/ethereum-attestation-service/eas-contracts/blob/master/contracts/resolver/examples/RevocationResolver.sol) |
| **Token Resolver**       | Checks if a specific amount of tokens has been approved for an attestation. It integrates token transactions into the attestation process. | [TokenResolver.sol](https://github.com/ethereum-attestation-service/eas-contracts/blob/master/contracts/resolver/examples/TokenResolver.sol) |
| **Value Resolver**       | Ensures that an attestation is accompanied by a specific amount of ETH. It's like paying a fee or deposit for the attestation. | [ValueResolver.sol](https://github.com/ethereum-attestation-service/eas-contracts/blob/master/contracts/resolver/examples/ValueResolver.sol) |


## Need Assistance or Have Queries?
If you're looking for guidance or have questions about resolver contracts, don't hesitate to reach out.

DM us on Twitter @eas_eth, and we'll set up a Telegram chat with your team to assist further!


================================================
FILE: docs/core--concepts/revocation.md
================================================
---
sidebar_position: 9
---

# Revocation
Attestations on EAS can be revoked when they are no longer valid or accurate. This can be done **both onchain and offchain**. Revoking an attestation will mark it as invalid. This can be useful in situations where an attestation was made in error, or if the data it represents has changed or become outdated. 

## Concept
Revoking an attestation involves changing its state from "valid" to "revoked". This is achieved by updating the attestation's `revoked` field to `true`. It allows for more control and flexibility over the attestations' lifecycle. 

An attestation may need to be revoked for various reasons, such as:

- The attestation is no longer valid or relevant.
- The attestation was issued in error or based on incorrect information.
- The underlying condition or requirement for the attestation has changed.

What if you don't want an attestation to be revocable? This can be controlled at the schema level which defines if attestations made of that schema type can be revoked. If you want more control over who can revoke, you can also consider setting a [resolver contract](/docs/core--concepts/resolver-contracts.md).

## Practical Application
Consider an attestation that certifies someone's role in an organization. If that role changes:

The original attestation is revoked, marking it as invalid.
A new attestation is made, possibly referencing the `UID` of the revoked attestation.
This ensures a clear history of the individual's roles over time, providing both transparency and accuracy.

Below is an example attestation where a DAO member's role was revoked.

![Example Revocation](./img/revoked-attestation-example.png)

## How Revocation Differs from Existing Mental Models
### Revocation vs. Token Burning
- **Revocation:** Marks an attestation as invalid but retains its history on the blockchain.
- **Burning:** Permanently removes a token from circulation, erasing its existence.

### Revocation vs. Replacement
While both concepts address the need to handle changes:
- **Revocation:** Marks the original attestation as invalid but doesn't alter or remove it. It provides a way to handle changes without erasing history.
- **Replacement:** Would imply completely removing the old attestation and creating a new one, which isn't how EAS operates due to the immutability of blockchain records.



================================================
FILE: docs/core--concepts/schemas.md
================================================
---
sidebar_position: 4
---

# Schemas
:::info What are schemas?
Schemas define the structure and type of data that can be included in an attestation. They act as a blueprint for the information being attested to, ensuring consistency and clarity.
:::

## Understanding Schemas
At its core, a schema is a structured framework that outlines the format of the data. In the context of EAS, schemas are essential because they ensure that attestations are consistent, readable, and verifiable. They dictate what kind of information can be attested to and how that information should be presented.

*Example Schema for "Making a Statement". It's simply just a `message string` schema. Notice that each schema has a UID 


![Make a Statement Schema](./img/make-a-statement-schema.png)

**Each schema record has the following fields:**
- `Schema #` - this is an incremental number automatically assigned to the Schema. It is not a unique identifier.
- `UID` - this is the unique universal identifier assigned to the schema.
- `Creator` - the wallet address that created the schema.
- `Transaction ID` - the Ethereum transaction registering the schema on EAS.
- `Resolver Contract` - An optional contract assigned to the Schema for more complex use cases.
- `Attestation Count` - The amount of attestations that have been made with attestations on/off chain.
- `Schema` - The ABI encoded schema field types.

### How Schemas Are Made
The [SchemaRegistry.sol](https://github.com/ethereum-attestation-service/eas-contracts/blob/master/contracts/SchemaRegistry.sol) contract is how schemas are made and registered. 

```javascript 
/// @notice A struct representing a record for a submitted schema.
struct SchemaRecord {
    bytes32 uid; // The unique identifier of the schema.
    ISchemaResolver resolver; // Optional schema resolver.
    bool revocable; // Whether the schema allows revocations explicitly.
    string schema; // Custom specification of the schema (e.g., an ABI).
}
```

**üéì Tutorial:** [**Make a Schema**](/docs/tutorials/create-a-schema.md)

## Building Efficient Schemas
When designing a schema, it's crucial to strike a balance between specificity and flexibility. Here are some guidelines:

- **Keep it Simple:** A schema should be concise. Avoid unnecessary complexity.
- **Be Descriptive:** Each field should have a clear purpose and name.
- **Avoid Redundancy:** Ensure each piece of information is captured once.
- **Plan for the Future:** Design your schema to be extendable without breaking existing attestations.
- **Gas Efficiency:** Consider the Ethereum gas costs. Using the right data types and thinking modularly will help reduce costs.

**üìò Read More:** [**Gas Efficiency Tutorial**](/docs/tutorials/gas-efficiency.md)

## Composability and Modularity
One of the strengths of EAS is its ability to create composable attestations. This principle can be applied to schemas as well:

- **Think Modular:** Instead of creating a monolithic schema that tries to capture everything, build smaller, modular schemas that can be combined as needed.
- **Reuse and Recombine:** Generalized schemas can be reused across different attestations. For instance, an `isTrue bool` schema can be applied in numerous contexts.

### Modular Schema Example: Event Attendance
Imagine you want to attest to someone attending an event:

- **Event Registration Schema:** This schema registers the event itself. It might include the event name, date, and venue.
- **Attendance Schema:** This schema attests to a person's attendance. Instead of repeating all the event details, it simply references the UID of the event from the Event Registration Schema.

This approach avoids data repetition and keeps the attestations lean and efficient.

## Collaborative Schema Development
While EAS provides the tools to create custom schemas tailored to specific needs, it also encourages collaboration. If you believe your schema has broader applicability beyond just your brand or project, it's beneficial to get input from the wider community. This collaborative approach ensures:

- **Standardization:** Common use cases can have standardized schemas, ensuring consistency across different projects.
- **Composability:** Schemas that are designed with input from various stakeholders are more likely to be composable, meaning they can be easily combined or used alongside other schemas.
- **Wider Adoption:** A schema that has been discussed and refined with community input is more likely to see wider adoption.

## Generalized vs. Complex Schemas
- **Generalized Schemas:** These are broad and can be applied in many situations. An example is the `isTrue` schema, which simply verifies the truth of a statement. Such schemas are versatile and can be used for a myriad of use cases.

- **Complex Schemas:** These are tailored for specific needs and are often built by communities or groups with shared interests. For instance, a schema for verifying art authenticity might include fields for the artist's name, artwork medium, creation date, and provenance.

:::tip Start a discussion
Coordination around schemas is crucial. If you have a more complex schema in mind for a particular use case, start a discussion on our forum.
:::

## Naming and Contextualizing Schemas
With EAS, you can use attestations to add more depth to your schemas:

- **Naming a Schema:** Instead of hardcoding a name within the schema, you can create an attestation that links a name to a schema's UID. This approach is more flexible and allows for names to evolve without altering the schema itself.

- **Add a Description:** Descriptions help others understand the purpose of your schema. You can easily set a description by making a referenced attestation to the schema `UID`. Simply use the "Schema Description" on any chain.

- **Providing Context:** Similarly, you can attest to the context or intended use of a schema. Simply reference the schema's UID, you can provide additional information or examples of how the schema should be used, without bloating the schema itself.

**üéì Tutorial:** [**Naming a Schema**](/docs/tutorials/naming-your-schema.md)

**üéì Tutorial:** [**Adding a Description**](/docs/tutorials/schema-description.md)

**üéì Tutorial:** [**Adding Context to a Schema**](/docs/tutorials/naming-your-schema.md)

## Conclusion
Schemas are foundational to the EAS ecosystem. They ensure that attestations are consistent, verifiable, and meaningful. Builders that think modularly, embrace composability, and leverage the power of attestations, can create powerful and flexible schemas that cater to a wide range of use cases.


================================================
FILE: docs/developer-tools/_category_.json
================================================
{
  "label": "Developer Tools",
  "position": 6,
  "link": {
    "type": "generated-index",
    "description": "Everything you need as a dev to get building faster."
  }
}



================================================
FILE: docs/developer-tools/api.md
================================================
---
sidebar_position: 2
---
# GraphQL API

Welcome to the Easscan GraphQL API documentation! This API allows you to access various attestation and schema data and perform queries using the GraphQL endpoints located at:

| Chain  | GraphQL endpoint                                                                                                      |
| ------------ |-----------------------------------------------------------------------------------------------------------------|
| Ethereum | [https://easscan.org/graphql](https://easscan.org/graphql)                                                          |
| Ethereum (Sepolia) | [https://sepolia.easscan.org/graphql](https://sepolia.easscan.org/graphql)                                |
| Arbitrum | [https://arbitrum.easscan.org/graphql](https://arbitrum.easscan.org/graphql)                                        |
| Arbitrum Nova | [https://arbitrum-nova.easscan.org/graphql](https://arbitrum-nova.easscan.org/graphql)                                        |
| Base | [https://base.easscan.org/graphql](https://base.easscan.org/graphql)                                                    |
| Base (Sepolia) | [https://base-sepolia.easscan.org/graphql](https://base-sepolia.easscan.org/graphql)                             |
| Optimism | [https://optimism.easscan.org/graphql](https://optimism.easscan.org/graphql)                                        |
| Optimism (Sepolia) | [https://optimism-sepolia-bedrock.easscan.org/graphql](https://optimism-sepolia-bedrock.easscan.org/graphql) |
| Scroll | [https://scroll.easscan.org/graphql](https://scroll.easscan.org/graphql)          
| Polygon | [https://polygon.easscan.org/graphql](https://polygon.easscan.org/graphql)                                        |
| Linea | [https://linea.easscan.org/graphql](https://linea.easscan.org/graphql)                                                 |
| Celo | [https://celo.easscan.org/graphql](https://celo.easscan.org/graphql)                                        |



## Introduction

GraphQL is a query language for your API, and a runtime for executing those queries against your data. With GraphQL, you can request exactly the data you need and nothing more, making it an efficient and flexible solution for client-server communication.

## Getting Started

To get started with the Easscan GraphQL API, you need to send an HTTP POST request to the endpoint with a JSON payload containing your GraphQL query.

Here's an example of how to make a request using `curl`:

```bash
curl --request POST \
    --header 'content-type: application/json' \
    --url 'https://easscan.org/graphql' \
    --data '{"query":"query Attestations {\n  attestations(take: 25) {\n    id\n    attester\n    recipient\n    refUID\n    revocable\n    revocationTime\n    expirationTime\n    data\n  }\n}","variables":{}}'
```

## Playground

To help you test and explore the API, we provide an interactive GraphQL Playground. The playground allows you to write queries, explore the schema, and see the results of your queries in real-time.

[https://easscan.org/graphql/playground](https://studio.apollographql.com/sandbox?endpoint=https%3A%2F%2Feasscan.org%2Fgraphql%2Fplayground)

## Example Queries

### Get the latest 25 attestations

```graphql
query Attestations {
  attestations(take: 25, orderBy: {time: desc}) {
    id
    attester
    recipient
    refUID
    revocable
    revocationTime
    expirationTime
    data
  }
}
```

### Get a specific Attestation by UID

```graphql
query Attestation {
  attestation(
    where: { id: "0xa4fb0ad1e13efbb38e466af0cb59822cae7f9ea26f26dd34ddb09c76ee9dbb12" }
  ) {
    id
    attester
    recipient
    refUID
    revocable
    revocationTime
    expirationTime
    data
  }
}
```



================================================
FILE: docs/developer-tools/eas-sdk.md
================================================
---
sidebar_position: 1
---

# EAS SDK

## Table of Contents

- [Installing the EAS SDK](#installing-the-eas-sdk)
- [Using the EAS SDK](#using-the-eas-sdk)
- [Getting an Attestation](#getting-an-attestation)
- [Creating Onchain Attestations](#creating-onchain-attestations)
  - [Example: Creating Onchain Attestations](#example-creating-onchain-attestations)
  - [Example: Creating Multi Onchain Attestations](#example-creating-multi-onchain-attestations)
- [Revoking Onchain Attestations](#revoking-onchain-attestations)
  - [Example: Revoking Onchain Attestations](#example-revoking-onchain-attestations)
- [Creating Offchain Attestations](#creating-offchain-attestations)
  - [Example: Creating Offchain Attestations](#example-creating-offchain-attestations)
- [Creating Delegated Onchain Attestations](#creating-delegated-onchain-attestations)
  - [Example: Creating Delegated Onchain Attestations](#example-creating-delegated-onchain-attestations)
- [Revoking Delegated Onchain Attestations](#revoking-delegated-onchain-attestations)
  - [Example: Revoking Delegated Onchain Attestations](#example-revoking-delegated-onchain-attestations)
- [Creating Timestamps](#creating-timestamps)
- [Revoking Offchain Attestations](#revoking-offchain-attestations)
- [Verifying an Offchain Attestation](#verifying-an-offchain-attestation)
- [Registering a Schema](#registering-a-schema)
- [Getting Schema Information](#getting-schema-information)
- [Using the PrivateData Class](#using-the-privatedata-class)
  - [Creating Private Data](#creating-private-data)
  - [Getting the Full Merkle Tree](#getting-the-full-merkle-tree)
  - [Generating a Multi-Proof](#generating-a-multi-proof)
  - [Verifying a Multi-Proof](#verifying-a-multi-proof)
  - [Verifying the Full Tree](#verifying-the-full-tree)
- [Example: Creating an Attestation with Private Data](#example-creating-an-attestation-with-private-data)

## Installing the EAS SDK

To install the EAS SDK, run the following command within your project directory:

```sh
yarn add @ethereum-attestation-service/eas-sdk
```

OR

```sh
npm install @ethereum-attestation-service/eas-sdk
```

OR

```sh
pnpm add @ethereum-attestation-service/eas-sdk
```

## Using the EAS SDK

Import and initialize the library

```javascript
import {
  EAS,
  Offchain,
  SchemaEncoder,
  SchemaRegistry,
} from "@ethereum-attestation-service/eas-sdk";
import { ethers } from "ethers";

export const EASContractAddress = "0xC2679fBD37d54388Ce493F1DB75320D236e1815e"; // Sepolia v0.26

// Initialize the sdk with the address of the EAS Schema contract address
const eas = new EAS(EASContractAddress);

// Gets a default provider (in production use something else like infura/alchemy)
const provider = ethers.getDefaultProvider("sepolia");

// Connects an ethers style provider/signingProvider to perform read/write functions.
// MUST be a signer to do write operations!
eas.connect(provider);
```

### Getting an Attestation

The `getAttestation` function allows you to retrieve an on-chain attestation for a given UID. This function returns an attestation object containing information about the attestation, such as the schema, recipient, attester, and more.

#### Usage

```javascript
import { EAS, NO_EXPIRATION } from "@ethereum-attestation-service/eas-sdk";

const eas = new EAS(EASContractAddress);
eas.connect(provider);

const uid =
  "0xff08bbf3d3e6e0992fc70ab9b9370416be59e87897c3d42b20549901d2cccc3e";

const attestation = await eas.getAttestation(uid);

console.log(attestation);
```

#### Output

The `getAttestation` function returns an attestation object with the following properties:

- `uid`: The unique identifier of the attestation.
- `schema`: The schema identifier associated with the attestation.
- `refUID`: The reference UID of the attestation, if any.
- `time`: The Unix timestamp when the attestation was created.
- `expirationTime`: The Unix timestamp when the attestation expires (0 for no expiration).
- `revocationTime`: The Unix timestamp when the attestation was revoked, if applicable.
- `recipient`: The Ethereum address of the recipient of the attestation.
- `attester`: The Ethereum address of the attester who created the attestation.
- `revocable`: A boolean indicating whether the attestation is revocable or not.
- `data`: The attestation data in bytes format.

Example output:

```javascript
{
    uid: '0x5134f511e0533f997e569dac711952dde21daf14b316f3cce23835defc82c065',
    schema: '0x27d06e3659317e9a4f8154d1e849eb53d43d91fb4f219884d1684f86d797804a',
    refUID: '0x0000000000000000000000000000000000000000000000000000000000000000',
    time: 1671219600,
    expirationTime: NO_EXPIRATION,
    revocationTime: 1671219636,
    recipient: '0xFD50b031E778fAb33DfD2Fc3Ca66a1EeF0652165',
    attester: '0x1e3de6aE412cA218FD2ae3379750388D414532dc',
    revocable: true,
    data: '0x0000000000000000000000000000000000000000000000000000000000000000'
}
```

### Creating Onchain Attestations

The `attest` function allows you to create an on-chain attestation for a specific schema. This function takes an object with the following properties:

- `schema`: The UID of the schema for which the attestation is being created.
- `data`: An object containing the following properties:
  - `recipient`: The Ethereum address of the recipient of the attestation.
  - `expirationTime`: A Unix timestamp representing the expiration time of the attestation. Use `0` for no expiration.
  - `revocable`: A boolean indicating whether the attestation is revocable or not.
  - `refUID`: (Optional) The UID of a referenced attestation. Use `ZERO_BYTES32` if there is no reference.
  - `data`: The encoded data for the attestation, which should be generated using the `SchemaEncoder` class.
  - `value`: (Optional) The ETH value that is being sent with the attestation.

The function returns a `Promise` that resolves to the UID of the newly created attestation.

#### Example: Creating Onchain Attestations

```javascript
import {
  EAS,
  NO_EXPIRATION,
  SchemaEncoder,
} from "@ethereum-attestation-service/eas-sdk";

const eas = new EAS(EASContractAddress);
eas.connect(signer);

// Initialize SchemaEncoder with the schema string
const schemaEncoder = new SchemaEncoder("uint256 eventId, uint8 voteIndex");
const encodedData = schemaEncoder.encodeData([
  { name: "eventId", value: 1, type: "uint256" },
  { name: "voteIndex", value: 1, type: "uint8" },
]);

const schemaUID =
  "0xb16fa048b0d597f5a821747eba64efa4762ee5143e9a80600d0005386edfc995";

const transaction = await eas.attest({
  schema: schemaUID,
  data: {
    recipient: "0xFD50b031E778fAb33DfD2Fc3Ca66a1EeF0652165",
    expirationTime: NO_EXPIRATION,
    revocable: true, // Be aware that if your schema is not revocable, this MUST be false
    data: encodedData,
  },
});

const newAttestationUID = await transaction.wait();

console.log("New attestation UID:", newAttestationUID);

console.log("Transaction receipt:", transaction.receipt);
```

#### Example: Creating Multi Onchain Attestations

```javascript
import {
  EAS,
  NO_EXPIRATION,
  SchemaEncoder,
} from "@ethereum-attestation-service/eas-sdk";

const eas = new EAS(EASContractAddress);
eas.connect(signer);

// Initialize SchemaEncoder with the schema string
const schemaEncoder = new SchemaEncoder("uint256 eventId, uint8 voteIndex");
const encodedData = schemaEncoder.encodeData([
  { name: "eventId", value: 1, type: "uint256" },
  { name: "voteIndex", value: 1, type: "uint8" },
]);
const encodedData2 = schemaEncoder.encodeData([
  { name: "eventId", value: 10, type: "uint256" },
  { name: "voteIndex", value: 2, type: "uint8" },
]);

const schemaUID =
  "0xb16fa048b0d597f5a821747eba64efa4762ee5143e9a80600d0005386edfc995";

const transaction = await eas.multiAttest([
  {
    schema: schemaId,
    data: [
      {
        recipient: "0xFD50b031E778fAb33DfD2Fc3Ca66a1EeF0652165",
        expirationTime: NO_EXPIRATION,
        revocable: true, // Be aware that if your schema is not revocable, this MUST be false
        data: encodedData,
      },
      {
        recipient: "0xA1207F3BBa224E2c9c3c6D5aF63D0eb1582Ce587",
        expirationTime: NO_EXPIRATION,
        revocable: false,
        data: encodedData2,
      },
    ],
  },
]);

const newAttestationUID = await transaction.wait();

console.log("New attestation UID:", newAttestationUID);

console.log("Transaction receipt:", transaction.receipt);
```

### Revoking Onchain Attestations

The `revoke` function allows you to revoke an on-chain attestation. This function takes an object with the following properties:

- `schema`: The UID of the schema for which the attestation is being revoke.
- `data`: An object containing the following properties:
  - `uid`: The UID of the attestation to revoke.
  - `value`: (Optional) The ETH value that is being sent with the revocation.

### Example: Revoking Onchain Attestations

```javascript
const transaction = await eas.revoke({
  schema: "0x85500e806cf1e74844d51a20a6d893fe1ed6f6b0738b50e43d774827d08eca61",
  data: {
    uid: "0x6776de8122c352b4d671003e58ca112aedb99f34c629a1d1fe3b332504e2943a",
  },
});

// Optional: Wait for transaction to be validated
await transaction.wait();
```

### Creating Offchain Attestations

To create an offchain attestation, you can use the `signOffchainAttestation` function provided by the Offchain class in the EAS SDK. Here's an example:

#### Example: Creating Offchain Attestations

```javascript
import {
  EAS,
  NO_EXPIRATION,
  SchemaEncoder,
} from "@ethereum-attestation-service/eas-sdk";

// Initialize EAS with the EAS contract address on whichever chain where your schema is defined
const eas = new EAS(EASContractAddress);

const offchain = await eas.getOffchain();

// Initialize SchemaEncoder with the schema string
// Note these values are sample values and should be filled with actual values
// Code samples can be found when viewing each schema on easscan.org
const schemaEncoder = new SchemaEncoder("uint256 eventId, uint8 voteIndex");
const encodedData = schemaEncoder.encodeData([
  { name: "eventId", value: 1, type: "uint256" },
  { name: "voteIndex", value: 1, type: "uint8" },
]);

// Signer is an ethers.js Signer instance
const signer = new ethers.Wallet(privateKey, provider);

const offchainAttestation = await offchain.signOffchainAttestation(
  {
    recipient: "0xFD50b031E778fAb33DfD2Fc3Ca66a1EeF0652165",
    expirationTime: NO_EXPIRATION, // Unix timestamp of when attestation expires (0 for no expiration)
    time: BigInt(Math.floor(Date.now() / 1000)), // Unix timestamp of current time
    revocable: true, // Be aware that if your schema is not revocable, this MUST be false
    schema:
      "0xb16fa048b0d597f5a821747eba64efa4762ee5143e9a80600d0005386edfc995",
    refUID:
      "0x0000000000000000000000000000000000000000000000000000000000000000",
    data: encodedData,
  },
  signer
);
```

This function will return a signed offchain attestation object containing the UID, signature, and attestation data. You can then share this object with the intended recipient or store it for future use.

#### Versioning

Since the offchain attestation protocol is being constantly evolved and improved, we've recently added versioning to help the applications to support both older and newer types of attestation. Starting from version `1`, we have added a `version` field to its typed data, which is seamlessly supported by both `signOffchainAttestation` and `verifyOffchainAttestationSignature` function.

Please note that using the `getOffchainUID` function for the previous legacy version, requires passing `{ version: 0 }` explicitly.

### Creating Delegated Onchain Attestations

The `attestByDelegation` function allows you to create a delegated on-chain attestation for a specific schema. This function takes an object with the following properties:

- `schema`: The UID of the schema for which the attestation is being created.
- `data`: An object containing the following properties:
  - `recipient`: The Ethereum address of the recipient of the attestation.
  - `expirationTime`: A Unix timestamp representing the expiration time of the attestation. Use `0` for no expiration.
  - `revocable`: A boolean indicating whether the attestation is revocable or not.
  - `refUID`: (Optional) The UID of a referenced attestation. Use `ZERO_BYTES32` if there is no reference.
  - `data`: The encoded data for the attestation, which should be generated using the `SchemaEncoder` class.
  - `value`: (Optional) The ETH value that is being sent with the attestation.
- `attester`: The address of the attester.
- `signature`: A EIP712 typed-signature (`r`, `s`, and `v`) over the message (using the `signDelegatedAttestation` function).
- `deadline`: A Unix representing the expiration time of the signature.

The function returns a `Promise` that resolves to the UID of the newly created attestation.

#### Example: Creating Delegated Onchain Attestations

```javascript
import {
  EAS,
  NO_EXPIRATION,
  SchemaEncoder,
} from "@ethereum-attestation-service/eas-sdk";

const eas = new EAS(EASContractAddress);

// Use a different account to send and pay for the attestation.
eas.connect(sender);

const delegated = await eas.getDelegated();

// Initialize SchemaEncoder with the schema string
// Note these values are sample values and should be filled with actual values
// Code samples can be found when viewing each schema on easscan.org
const schemaEncoder = new SchemaEncoder("uint256 eventId, uint8 voteIndex");
const encodedData = schemaEncoder.encodeData([
  { name: "eventId", value: 1, type: "uint256" },
  { name: "voteIndex", value: 1, type: "uint8" },
]);

const signer = new ethers.Wallet(privateKey, provider);

// Please note that if nonce isn't provided explicitly, we will try retrieving it onchain.
const response = await delegated.signDelegatedAttestation(
  {
    schema:
      "0xb16fa048b0d597f5a821747eba64efa4762ee5143e9a80600d0005386edfc995",
    recipient: "0xFD50b031E778fAb33DfD2Fc3Ca66a1EeF0652165",
    expirationTime: NO_EXPIRATION, // Unix timestamp of when attestation expires (0 for no expiration)
    revocable: true,
    refUID:
      "0x0000000000000000000000000000000000000000000000000000000000000000",
    data: encodedData,
    deadline: NO_EXPIRATION, // Unix timestamp of when signature expires (0 for no expiration)
    value: 0n,
  },
  signer
);

const transaction = await eas.attestByDelegation({
  schema: "0xb16fa048b0d597f5a821747eba64efa4762ee5143e9a80600d0005386edfc995",
  data: {
    recipient: "0xFD50b031E778fAb33DfD2Fc3Ca66a1EeF0652165",
    expirationTime: NO_EXPIRATION, // Unix timestamp of when attestation expires (0 for no expiration),
    revocable: true,
    refUID:
      "0x0000000000000000000000000000000000000000000000000000000000000000",
    data: encodedData,
  },
  signature: response.signature,
  attester: await signer.getAddress(),
  deadline: 0n, // Unix timestamp of when signature expires (0 for no expiration)
});

const newAttestationUID = await transaction.wait();

console.log("New attestation UID:", newAttestationUID);

console.log("Transaction receipt:", transaction.receipt);
```

### Revoking Delegated Onchain Attestations

The `revokeByDelegation` function allows you to create a delegated on-chain revocation for a specific attestation. This function takes an object with the following properties:

- `schema`: The UID of the schema for which the attestation is being revoke.
- `data`: An object containing the following properties:
  - `uid`: The UID of the attestation to revoke.
  - `value`: (Optional) The ETH value that is being sent with the revocation.
- `revoker`: The address of the revoker.
- `signature`: A EIP712 typed-signature (`r`, `s`, and `v`) over the message (using the `signDelegatedRevocation` function).
- `deadline`: A Unix representing the expiration time of the signature.

The function returns a `Promise` that resolves to the UID of the newly created attestation.

#### Example: Revoking Delegated Onchain Attestations

```javascript
import { EAS, SchemaEncoder } from "@ethereum-attestation-service/eas-sdk";

const eas = new EAS(EASContractAddress);

// Use a different account to send and pay for the attestation.
eas.connect(sender);

const delegated = await eas.getDelegated();

const signer = new ethers.Wallet(privateKey, provider);

const transaction = await eas.revoke({
  schema: "0x85500e806cf1e74844d51a20a6d893fe1ed6f6b0738b50e43d774827d08eca61",
  data: {
    uid: "0x6776de8122c352b4d671003e58ca112aedb99f34c629a1d1fe3b332504e2943a",
  },
});

// Please note that if nonce isn't provided explicitly, we will try retrieving it onchain.
const response = await delegated.signDelegatedRevocation(
  {
    schema:
      "0x85500e806cf1e74844d51a20a6d893fe1ed6f6b0738b50e43d774827d08eca61",
    uid: "0x6776de8122c352b4d671003e58ca112aedb99f34c629a1d1fe3b332504e2943a",
    deadline: 0n, // Unix timestamp of when signature expires (0 for no expiration)
    value: 0n,
  },
  signer
);

const transaction = await eas.revokeByDelegation({
  schema: "0xb16fa048b0d597f5a821747eba64efa4762ee5143e9a80600d0005386edfc995",
  data: {
    uid: "0x6776de8122c352b4d671003e58ca112aedb99f34c629a1d1fe3b332504e2943a",
  },
  signature: response.signature,
  revoker: await signer.getAddress(),
  deadline: 0n, // Unix timestamp of when signature expires (0 for no expiration)
});

// Optional: Wait for transaction to be validated
await transaction.wait();
```

### Creating Timestamps

To timestamp an off-chain attestation UID on-chain, you can use the timestamp function provided by the EAS SDK. Here's an example:

```javascript
import { EAS } from "@ethereum-attestation-service/eas-sdk";

const eas = new EAS(EASContractAddress);
eas.connect(provider);

const uid =
  "0x6776de8122c352b4d671003e58ca112aedb99f34c629a1d1fe3b332504e2943a";

const transaction = await eas.timestamp(uid);

// Optional: Wait for the transaction to be validated
await transaction.wait();
```

To create a timestamp for a any piece of data, you can use the `timestamp` function provided by the EAS SDK. Here's an example:

```javascript
import { EAS } from "@ethereum-attestation-service/eas-sdk";

const eas = new EAS(EASContractAddress);
eas.connect(provider);

const data = ethers.encodeBytes32String("0x1234");

const transaction = await eas.timestamp(data);

// Optional: Wait for transaction to be validated
await transaction.wait();
```

To create timestamps for multiple pieces of data, you can use the `multiTimestamp` function:

```javascript
import { EAS } from "@ethereum-attestation-service/eas-sdk";

const eas = new EAS(EASContractAddress);
eas.connect(provider);

const data1 = ethers.encodeBytes32String(
  "0x3e23b395b2bd2d37dd0f6e4148ac6b9e7ed22f2215107958f95cc1489e4e6289"
);
const data2 = ethers.encodeBytes32String(
  "0x6776de8122c352b4d671003e58ca112aedb99f34c629a1d1fe3b332504e2943a"
);

const transaction = await eas.multiTimestamp([data1, data2]);

// Optional: Wait for transaction to be validated
await transaction.wait();
```

### Revoking Offchain Attestations

To revoke an offchain attestation, you can use the `revokeOffchain` function provided by the EAS SDK. Here's an example:

```javascript
import { EAS } from "@ethereum-attestation-service/eas-sdk";

const eas = new EAS(EASContractAddress);
eas.connect(provider);

const data = ethers.encodeBytes32String(
  "0x6776de8122c352b4d671003e58ca112aedb99f34c629a1d1fe3b332504e2943a"
);

const transaction = await eas.revokeOffchain(data);

// Optional: Wait for transaction to be validated
await transaction.wait();
```

To revoke multiple offchain attestations, you can use the `multiRevokeOffchain` function:

```javascript
import { EAS } from "@ethereum-attestation-service/eas-sdk";

const eas = new EAS(EASContractAddress);
eas.connect(provider);

const data1 = ethers.encodeBytes32String(
  "0x6776de8122c352b4d671003e58ca112aedb99f34c629a1d1fe3b332504e2943a"
);
const data2 = ethers.encodeBytes32String(
  "0x3e23b395b2bd2d37dd0f6e4148ac6b9e7ed22f2215107958f95cc1489e4e6289"
);

const transaction = await eas.multiRevokeOffchain([data1, data2]);

// Optional: Wait for transaction to be validated
await transaction.wait();
```

### Verifying an Offchain Attestation

To verify an offchain attestation, you can use the `verifyOffchainAttestationSignature` function provided by the EAS SDK. Here's an example:

```javascript
import {
  OffchainAttestationVersion,
  Offchain,
  OffchainConfig,
} from "@ethereum-attestation-service/eas-sdk";

const attestation = {
  // your offchain attestation
  sig: {
    domain: {
      name: "EAS Attestation",
      version: "0.26",
      chainId: 1,
      verifyingContract: "0xA1207F3BBa224E2c9c3c6D5aF63D0eb1582Ce587",
    },
    primaryType: "Attest",
    types: {
      Attest: [],
    },
    signature: {
      r: "",
      s: "",
      v: 28,
    },
    uid: "0x5134f511e0533f997e569dac711952dde21daf14b316f3cce23835defc82c065",
    message: {
      version: OffchainAttestationVersion.Version2,
      schema:
        "0x27d06e3659317e9a4f8154d1e849eb53d43d91fb4f219884d1684f86d797804a",
      refUID:
        "0x0000000000000000000000000000000000000000000000000000000000000000",
      time: 1671219600,
      expirationTime: NO_EXPIRATION,
      recipient: "0xFD50b031E778fAb33DfD2Fc3Ca66a1EeF0652165",
      attester: "0x1e3de6aE412cA218FD2ae3379750388D414532dc",
      revocable: true,
      data: "0x0000000000000000000000000000000000000000000000000000000000000000",
    },
  },
  signer: "0x1e3de6aE412cA218FD2ae3379750388D414532dc",
};

const EAS_CONFIG: OffchainConfig = {
  address: attestation.sig.domain.verifyingContract,
  version: attestation.sig.domain.version,
  chainId: attestation.sig.domain.chainId,
};
const offchain = new Offchain(EAS_CONFIG, OffchainAttestationVersion.Version2);
const isValidAttestation = offchain.verifyOffchainAttestationSignature(
  attestation.signer,
  attestation.sig
);
```

### Registering a Schema

To register a new schema, you can use the `register` function provided by the EAS SDK. This function takes an object with the following properties:

- `schema`: The schema string that defines the structure of the data to be attested.
- `resolverAddress`: The Ethereum address of the resolver responsible for managing the schema.
- `revocable`: A boolean value indicating whether attestations created with this schema can be revoked.

Here's an example of how to register a new schema:

```javascript
import { SchemaRegistry } from "@ethereum-attestation-service/eas-sdk";
import { ethers } from "ethers";

const schemaRegistryContractAddress = "0xYourSchemaRegistryContractAddress";
const schemaRegistry = new SchemaRegistry(schemaRegistryContractAddress);

schemaRegistry.connect(signer);

const schema = "uint256 eventId, uint8 voteIndex";
const resolverAddress = "0x0a7E2Ff54e76B8E6659aedc9103FB21c038050D0"; // Sepolia 0.26
const revocable = true;

const transaction = await schemaRegistry.register({
  schema,
  resolverAddress,
  revocable,
});

// Optional: Wait for transaction to be validated
await transaction.wait();
```

After registering a schema, you can use its UID to create attestations with the specified structure.

### Getting Schema Information

To retrieve the schema information for a specific schema UID, you can use the `getSchema` function provided by the EAS SDK. Here's an example:

```javascript
import { SchemaRegistry } from "@ethereum-attestation-service/eas-sdk";

const schemaRegistryContractAddress = "0x0a7E2Ff54e76B8E6659aedc9103FB21c038050D0"; // Sepolia 0.26
const schemaRegistry = new SchemaRegistry(schemaRegistryContractAddress);
schemaRegistry.connect(provider);

const schemaUID = "0xYourSchemaUID";

const schemaRecord = await schemaRegistry.getSchema({ uid: schemaUID });

console.log(schemaRecord);

// Example Output
{
  uid: '0xYourSchemaUID',
  schema: 'bytes32 proposalId, bool vote',
  resolver: '0xResolverAddress',
  revocable: true
}
```

In the output, you will receive an object containing the schema UID, the schema string, the resolver address, and a boolean indicating whether the schema is revocable or not.

### Using the PrivateData Class

The `PrivateData` class allows you to create, prove, and verify private data using Merkle trees. This is useful for creating attestations where you want to selectively reveal only certain pieces of information while keeping the rest private.

#### Creating Private Data

To create private data, you need to initialize a `PrivateData` instance with an array of `MerkleValue` objects:

```typescript
import {
  MerkleValue,
  PrivateData,
} from "@ethereum-attestation-service/eas-sdk";

const values: MerkleValue[] = [
  { type: "string", name: "name", value: "Alice Johnson" },
  { type: "uint256", name: "age", value: 28 },
  { type: "bool", name: "isStudent", value: false },
  {
    type: "address",
    name: "wallet",
    value: "0x742d35Cc6634C0532925a3b844Bc454e4438f44e",
  },
  {
    type: "bytes32",
    name: "dataHash",
    value: ethers.id("confidential information"),
  },
];

const privateData = new PrivateData(values);
```

#### Getting the Full Merkle Tree

You can retrieve the full Merkle tree, which includes the root and all values with their salts:

```typescript
const fullTree = privateData.getFullTree();
console.log("Merkle Root:", fullTree.root);
```

#### Generating a Multi-Proof

To selectively reveal only certain pieces of information, you can generate a multi-proof:

```typescript
const proofIndexes = [0, 2, 4]; // Proving name, isStudent, and dataHash
const multiProof = privateData.generateMultiProof(proofIndexes);
```

#### Verifying a Multi-Proof

To verify a multi-proof against a known Merkle root:

```typescript
const isValid = PrivateData.verifyMultiProof(fullTree.root, multiProof);
console.log("Is Multi-Proof Valid?", isValid);
```

#### Verifying the Full Tree

You can also verify the integrity of the full Merkle tree:

```typescript
const calculatedRoot = PrivateData.verifyFullTree(fullTree);
console.log("Is Full Tree Valid?", calculatedRoot === fullTree.root);
```

### Example: Creating an Attestation with Private Data

Here's an example of how you might use the `PrivateData` class in conjunction with the EAS SDK to create an attestation with private data:

```typescript
import {
  EAS,
  NO_EXPIRATION,
  MerkleValue,
  PrivateData,
  SchemaEncoder,
} from "@ethereum-attestation-service/eas-sdk";
import { ethers } from "ethers";

// Initialize EAS
const eas = new EAS(EASContractAddress);
eas.connect(signer);

// Create private data
const values: MerkleValue[] = [
  { type: "string", name: "name", value: "Alice Johnson" },
  { type: "uint256", name: "age", value: 28 },
  { type: "bool", name: "isStudent", value: false },
  {
    type: "address",
    name: "wallet",
    value: "0x742d35Cc6634C0532925a3b844Bc454e4438f44e",
  },
  {
    type: "bytes32",
    name: "dataHash",
    value: ethers.id("confidential information"),
  },
];

const privateData = new PrivateData(values);
const fullTree = privateData.getFullTree();

// Create an attestation with the Merkle root
const schemaEncoder = new SchemaEncoder("bytes32 privateData");
const encodedData = schemaEncoder.encodeData([
  { name: "privateData", value: fullTree.root, type: "bytes32" },
]);

// Private data schema
const schemaUID =
  "0x20351f973fdec1478924c89dfa533d8f872defa108d9c3c6512267d7e7e5dbc2";

const transaction = await eas.attest({
  schema: schemaUID,
  data: {
    recipient: "0xFD50b031E778fAb33DfD2Fc3Ca66a1EeF0652165",
    expirationTime: NO_EXPIRATION,
    revocable: true,
    data: encodedData,
  },
});

const newAttestationUID = await transaction.wait();

console.log("New attestation UID:", newAttestationUID);

// Generate a multi-proof to selectively reveal some data
const proofIndexes = [0, 2]; // Revealing only name and isStudent
const multiProof = privateData.generateMultiProof(proofIndexes);

console.log("Multi-proof for selective reveal:", multiProof);
```

In this example, we create an attestation that includes only the Merkle root of the private data. The actual data remains private, but we can selectively reveal parts of it using the multi-proof. The recipient of this attestation can verify the multi-proof against the attested Merkle root to confirm the validity of the revealed data without seeing the entire dataset.



================================================
FILE: docs/developer-tools/hash-a-file.md
================================================
---
sidebar_position: 5
---

# Hash Any File
You can find a simple way to quickly generate a hash of any file in the [**Tools**](https://easscan.org/tools) section of the easscan.org website. Hashing a file doesn't upload or store the file anywhere, it simply generates a unique bytes32 hash of the document using SHA256. 

You can hash any local file:
- A software release
- Podcasts and video files
- Documents and PDFs
- Images
- Any type of file

## Understanding How Hash's Work
A hash function like `SHA256` takes an input (or 'message') and returns a fixed-size string of bytes. The output, typically a 'digest', is unique to each unique input. Even a minor change, like a single letter or single pixel of the file changes, it will produce a vastly different output, this is also known as the `avalanche effect`. This makes hashing a powerful tool for verifying data integrity. 

SHA-256, which stands for Secure Hash Algorithm 256-bit, is one of the cryptographic hash functions in the SHA-2 family. It's widely used in the world of cryptography and is integral to the functioning of modern technologies, including blockchain systems.

:::info Irreversible
You cannot deduce the original input from its hash, you can only generate the same hash by having the same input.
:::

## The Value of Hashing & Attesting
Once you've hashed a file, you can attest to that hash. This creates an immutable record of the file's hash at that specific moment. If anyone wishes to confirm the file's authenticity in the future, they can refer to your attestation, upload the same file, and check if the hashes align.

As more and more deep fakes and misinformation is spread by the rise of generative AI, we need a way to combat the provenance and authenticity of files and information. Attestations are a great way to combat this. Here are some things you can consider hashing:
- Prove the origin of content, such as podcast audio or videos.
- Track the provenance and evolution of images over time.
- Preserve historical data, ensuring its authenticity with a verifiable timestamp.

## Example: Hashing & Attesting a Document 
Let's take the [**Ethereum Whitepaper from 2014**](https://ethereum.org/669c9e2e2027310b6b3cdce6e1c52962/Ethereum_Whitepaper_-_Buterin_2014.pdf) as an example. You can follow along if you'd like!

1. **Generate the Hash:** Upload the whitepaper to the container on EASSCAN. You'll receive a hash like:
`0x4cc15f99f5df56c8a7156188a9b9290c71e7dfd9a92093b028213c9a185c0a15`
![Uploadfile](./img/get-a-hash.png)

2. **Find a Suitable Schema:** Use a schema like `contentHash bytes32`. For instance, on Sepolia, you can find it [here](https://sepolia.easscan.org/schema/view/0xdf4c41ea0f6263c72aa385580124f41f2898d3613e86c50519fc3cfd7ff13ad4).
![ContentHash Schema](./img/content-hash-schema.png)

3. **Attest to the Hash:** With the generated hash, you can now create an attestation.
![Content Hash Attestation](./img/make-hash-attestation.png)

4. **Attestation Made:** Now you have an attestation that is attesting to the `bytes32` hash of the whitepaper.
![Content Hash Attestation](./img/hash-attestation.png)

5. **Verification:** Here's the onchain attestation record for the `Ethereum Whitepaper`. To validate its authenticity, upload the same PDF. If unchanged, it will produce the identical hash, confirming its authenticity. If there's a mismatch, it indicates alterations.
[**Example Attestation**](https://sepolia.easscan.org/attestation/view/0xb2fd51f0b6f71baa4fbca4f6761e5e8125fd48984de793b684192ccb20c7e09e).

- Here's an example of the **WRONG file** being uploaded, which generates the wrong hash.
![Not Verified](./img/not-verified-hash.png)

- If we upload the **SAME PDF**, and nothing has been altered, then it will generate the same hash.
![Verified](./img/verified-hash.png)

## Wrapping Up
Hashing and attesting files on EASSCAN provides a robust mechanism to ensure and verify file authenticity. Whether you're a content creator, historian, or just someone looking to preserve digital integrity, this tool is invaluable. Start attesting today and be part of a more transparent digital future.



================================================
FILE: docs/developer-tools/sdk-wagmi.md
================================================
---
title: Integrating eas-sdk with wagmi library
sidebar_label: Using SDK with viem/wagmi
sidebar_position: 2
---

# SDK with WAGMI
Since `wagmi` now no longer uses `ethers` and instead uses a new library called `viem`, users need to convert the `viem` style `publicClient` and `walletClient` to `ethers` style `provider` and `signer` to use the `eas-sdk`.

### Using useSigner and useProvider Hooks

The two hooks, `useSigner` and `useProvider`, make this conversion easy for you. You don't need to install a whole separate library to do this conversion, simply add [these](https://gist.github.com/slavik0329/2e5b6fc31cb745b65d3d37f7cf1d7b36) hooks to your project.

#### **useSigner Hook**

The `useSigner` hook gets the `walletClient` and returns a signer compatible with `ethers`.

Usage:

```typescript
const signer = useSigner();
```

#### **useProvider Hook**

The `useProvider` hook gets the `publicClient` and returns a provider compatible with `ethers`.

Usage:

```typescript
const signer = useProvider();
```

### Code Implementation

You can find the code for the `useSigner` and `useProvider` hooks [here](https://gist.github.com/slavik0329/2e5b6fc31cb745b65d3d37f7cf1d7b36).

This code imports necessary types from `wagmi` and `viem`, and defines two conversion functions (`publicClientToProvider` and `walletClientToSigner`) along with the two hooks.




================================================
FILE: docs/developer-tools/verify-attestation.md
================================================
---
sidebar_position: 3
---

# Verify Offchain Attestation

There are a few ways you can verify an offchain attestation. A simple route to quickly verify an offchain attestation is using the https://easscan.org explorer on the chain.


## Using the Attestation Explorer Tools
For this example, we'll use a completely offchain attestation made on Sepolia. This attestation is not stored anywhere and can be passed peer-to-peer. The attestation data is completely encoded in the URI fragment of the URL:

![Offchain Attestation](./img/Sample-offchain-attestation.png)

If you have the raw data of the attestation in a file, you can upload the attestation and it will verify that it is a valid signature. If the data is a valid attestation, the easscan web app will decode the attestation and display it for you.

![Offchain Attestation](./img/verify-offchain-box.png)

### Example Attestation

```javascript
{"sig":{"domain":{"name":"EAS Attestation","version":"0.26","chainId":11155111,"verifyingContract":"0xC2679fBD37d54388Ce493F1DB75320D236e1815e"},"primaryType":"Attest","types":{"Attest":[{"name":"version","type":"uint16"},{"name":"schema","type":"bytes32"},{"name":"recipient","type":"address"},{"name":"time","type":"uint64"},{"name":"expirationTime","type":"uint64"},{"name":"revocable","type":"bool"},{"name":"refUID","type":"bytes32"},{"name":"data","type":"bytes"}]},"signature":{"r":"0x96148fae1b641d7c0750a46aa5775c1840433d69705ae6edfbd7740eff49cc55","s":"0x0e0283146242cdafb137b704b7ded3496b90241455b2ececc33c344515c364ce","v":28},"uid":"0x268702f425d0704c4ad4677c6aded987827b0e74d33029162dbf245e0297c15f","message":{"version":1,"schema":"0x3969bb076acfb992af54d51274c5c868641ca5344e1aacd0b1f5e4f80ac0822f","recipient":"0x0000000000000000000000000000000000000000","time":1694196775,"expirationTime":0,"refUID":"0x0000000000000000000000000000000000000000000000000000000000000000","revocable":true,"data":"0x0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000003c5468697320697320612073616d706c65206f6666636861696e206174746573746174696f6e20746861742063616e206265207665726966696564212000000000","nonce":0}},"signer":"0xeee68aECeB4A9e9f328a46c39F50d83fA0239cDF"}
```

https://sepolia.easscan.org/offchain/url/#attestation=eNqlUUtqZDEMvMtbN0F%2FWct09%2FQlhlnYsn2AYQZy%2FOg9AjlADBa2KFeVyr8PeCM7boioWuV2wMeDzGPfn%2BxThVt7LAl%2B4fPuygRPYlvYUNdxgsNQ2u4LhwlOT3CFLta7umtiExDmaeGgfdmae0x3gbW3RKbqRQILqDGKkVDOvgeyDwcZPtdkCRsBJCiqg1auTOZkEUVNNslyQu3kWWtZ678e6y7vsWIztfKSHC%2BF2Xi%2FA3Hk83WJkjUH2kI6obRS%2BhRzT%2BslGs0b%2BYDlMpmBAo3m2CRaVsMTdV8kHBZjgFvPPSKob5WpSC6p2axVKNm1vC7sPScM3LpkN%2BgJjegiqfQtBKPE9QZX49%2Ff%2F%2BsK5keLfvYcOFVqhPD69q%2BKBM6GNh0sTauz7VxcuJrC1olxcTF1rlrn6u6z7ydX3QtxMpxIOhncCkuFstpqQvjt%2B6g88M8nmsefLg%3D%3D


## Verifying Offchain Attestations with the SDK
To verify an offchain attestation, you can use the verifyOffchainAttestationSignature function provided by the EAS SDK. 

**Read More:** [**EAS SDK Docs**](https://github.com/ethereum-attestation-service/eas-sdk)

Here's an example:
```javascript
import { OFFCHAIN_ATTESTATION_VERSION, Offchain, PartialTypedDataConfig } from "@ethereum-attestation-service/eas-sdk";

const attestation = {
  // your offchain attestation
  sig: {
    domain: {
      name: "EAS Attestation",
      version: "0.26",
      chainId: 1,
      verifyingContract: "0xA1207F3BBa224E2c9c3c6D5aF63D0eb1582Ce587",
    },
    primaryType: "Attest",
    types: {
      Attest: [],
    },
    signature: {
      r: "",
      s: "",
      v: 28,
    },
    uid: "0x5134f511e0533f997e569dac711952dde21daf14b316f3cce23835defc82c065",
    message: {
      version: 1,
      schema: "0x27d06e3659317e9a4f8154d1e849eb53d43d91fb4f219884d1684f86d797804a",
      refUID: "0x0000000000000000000000000000000000000000000000000000000000000000",
      time: 1671219600,
      expirationTime: 0,
      recipient: "0xFD50b031E778fAb33DfD2Fc3Ca66a1EeF0652165",
      attester: "0x1e3de6aE412cA218FD2ae3379750388D414532dc",
      revocable: true,
      data: "0x0000000000000000000000000000000000000000000000000000000000000000",
    },
  },
  signer: "0x1e3de6aE412cA218FD2ae3379750388D414532dc",
};

const EAS_CONFIG: PartialTypedDataConfig = {
  address: attestation.sig.domain.verifyingContract,
  version: attestation.sig.domain.version,
  chainId: attestation.sig.domain.chainId,
};
const offchain = new Offchain(EAS_CONFIG, OFFCHAIN_ATTESTATION_VERSION);
const isValidAttestation = offchain.verifyOffchainAttestationSignature(
  attestation.signer,
  attestation.sig
);

```



================================================
FILE: docs/developer-tools/verify-timestamp.md
================================================
---
sidebar_position: 4
---

# Batch Timestamping
Timestamping is a crucial aspect of ensuring the authenticity and integrity of data. Timestamping provides a verifiable proof of existence for offchain attestations. This doc delves into the concept of Merkle Trees and how they can be used to efficiently timestamp multiple offchain attestations in a single transaction.

## Understanding Merkle Trees
A Merkle Tree is a binary tree where each leaf node represents a piece of data, and each non-leaf node is a hash of its child nodes. The topmost node, known as the Merkle Root, provides a single hash representation for all the data in the tree.

### Key Features:
- **Efficiency:** Allows for efficient and secure verification of large data sets.
- **Proof of Inclusion:** Any piece of data can be verified to be a part of the tree by providing a 'proof path', a sequence of hashes leading to the Merkle Root.
- **Immutability:** Any change in data, even at the leaf level, results in a change in the Merkle Root.

## Why Timestamp Offchain Attestations?
Offchain attestations, by their nature, lack an onchain consensus timestamp, making their exact time of creation unverifiable. Timestamping the UID of the offchain attestation onchain provides:

- **Proof of Existence:** It proves that the attestation existed at or before the timestamp.
- **Data Integrity:** The UID, being a unique hash of the entire valid attestation data, ensures that the attestation hasn't been altered post-timestamping.

## Batch Timestamping with Merkle Trees
While individual timestamping is straightforward, it may not be efficient for large volumes of attestations. This is where Merkle Trees shine:

- **Batch Multiple UIDs:** Instead of timestamping each UID individually, multiple UIDs are combined to form a Merkle Tree.
- **Generate the Merkle Root:** The Merkle Root, representing all the UIDs, is generated.
- **Single Onchain Transaction:** Only the Merkle Root is timestamped onchain, saving on transaction costs and gas.
- **Proof of Inclusion:** Any individual UID can later be verified against the timestamped Merkle Root.

## Using easscan.org for Batch Timestamping
EAS provides a simple container on the easscan.org site to facilitate this process:

- **Paste UIDs:** Users can easily paste multiple offchain attestation UIDs.
- **Timestamp All:** Upon clicking "Timestamp All", the site generates the Merkle Root for all the UIDs.
- **Onchain Timestamping:** The platform assists users in creating an onchain timestamp for the Merkle Root.
- **Results Page:** Post timestamping, users receive a results page listing all UIDs that are part of the timestamped Merkle Root.

## Example Flow
Here's an example batch timestamp flow on Sepolia.

1. First we go to the [Tools] page on Easscan. Scroll to the bottom and we'll see the `Offchain multi-timestamp` container. This allows you to paste attestation UIDs on separate lines.

![Timestamp Container](./img/offchain-timestamp-container.png)

2. Paste the UID's you want to timestamp and click `Timestamp all`.
![Timestamp UID List](./img/batch-timestamp-list.png)


3. Nice! Now we can see the `Batch Timestamp Details` which generated a Merkle Tree of the **12** `UIDs`. You can see the onchain transaction ID of `0xb63fcec1b612fbcd3c2c4e301cc6d9fad4d0bb11234be817ecd014c2661d0f85`. You can see this example here: [https://sepolia.easscan.org/timestamp/0xb63fcec1b612fbcd3c2c4e301cc6d9fad4d0bb11234be817ecd014c2661d0f85](https://sepolia.easscan.org/timestamp/0xb63fcec1b612fbcd3c2c4e301cc6d9fad4d0bb11234be817ecd014c2661d0f85)
![Timestamp Result](./img/timestamp-result.png)

4. When you go to a public offchain attestation record that has been timestamped, you'll see there is an `onchain timestamp` in the top right hand side of the attestation record. You can click the eye and it will take you to the merkle tree record and highlight the `UID` is in fact a part of the batch timestamp record. 
![Timestamp Result](./img/onchain-timestamp-record.png)

5. This is showing that the `UID` of the offchain attestation was found in the merkle tree.
![Timestamp Highlighted](./img/timestamp-highlighted.png)



## Conclusion
Merkle Trees offer a powerful and efficient mechanism to timestamp large volumes of offchain attestations with a single onchain transaction. This ensures not only the proof of existence but also the integrity of the attestations, providing a robust and cost-effective solution for developers and users alike.



================================================
FILE: docs/developer-tools/img/Sample-offchain-attestation.textClipping
================================================
[Binary file]


================================================
FILE: docs/developer-tools/metamask-snap/_category_ 2.json
================================================
{
  "label": "MetaMask Snaps",
  "position": 1,
  "link": {
    "type": "generated-index",
    "description": "Get inspired on what to build."
  }
}



================================================
FILE: docs/developer-tools/metamask-snap/eas-snap-faq.md
================================================
---
sidebar_position: 9
---

# Snap FAQs
Have a few questions about the Snap? Check out the FAQs below or reach out to us in our telegram group.

<details>
<summary>What is the EAS MetaMask Snap?</summary> 
The EAS MetaMask Snap is a tool that decodes attestation data in MetaMask transactions, converting it into a readable format. This helps users understand the details of what they're signing, enhancing transparency and security in the attestation process.
</details>

<details>
<summary>How does the EAS Snap enhance security? </summary>
It provides a clear, human-readable format of the attestation data, the EAS Snap ensures users are fully aware of the content they are signing. This reduces the risk of unintentional or malicious attestations.
</details>

<details>
<summary>Is the EAS MetaMask Snap easy to use?</summary>
Yes, it is designed to integrate seamlessly with MetaMask and is user-friendly, catering to both beginners and experienced users.
</details>

<details>
<summary>Can the EAS Snap decode any Ethereum transaction?</summary>
No. The EAS Snap specifically decodes transactions related to Ethereum Attestations. It identifies and processes data related to EAS attestations.
</details>

<details>
<summary>What details does the EAS Snap provide about an attestation?</summary>
The snap displays various details such as the schema, recipient, reference UID, expiration time, and revocability status of the attestation.
</details>

<details>
<summary>Do I need any special skills to use the EAS Snap?</summary>
No special skills are required. If you're familiar with using MetaMask, you can easily use the EAS Snap.
</details>

<details>
<summary>Is there a cost associated with using the EAS MetaMask Snap?</summary>
The snap itself is free to use, but standard Ethereum network transaction fees apply.
</details>

<details>
<summary>How do I install and activate the EAS MetaMask Snap? </summary>
You can find the Snap in the Snap's directory page. Then click 'Add to MetaMask'. Installation instructions are usually provided in the Snap documentation or on the website where the Snap is hosted.
</details>

<details>
<summary>What is an 'attestation' in the context of Ethereum?</summary>
An attestation is a digital signature on structured data, used to verify information or assert trust in a decentralized manner. Learn more about them in the EAS docs.
</details>

<details>
<summary>Can the EAS Snap be used with any Ethereum wallet?</summary>
Currently, the EAS Snap is designed for use with the MetaMask browser extension and is not be compatible with other Ethereum wallets.
</details>


================================================
FILE: docs/developer-tools/metamask-snap/install-snap.md
================================================
---
sidebar_position: 8
---

# Install the Snap
To begin using the EAS MetaMask Snap, you'll need to have the MetaMask extension installed in your web browser. If you haven't already installed MetaMask, you can download it from [**MetaMask's official website**](https://metamask.io/).

## Step-by-Step Installation Guide
1. **Open MetaMask Extension** Click on the MetaMask icon in your browser to open the extension.

2. **Access the Snaps Feature** 
In the MetaMask UI, locate the 'Snaps' section. This can usually be found in the settings or extensions menu within MetaMask.

3. **Add EAS MetaMask Snap**
Look for an option to 'Discover Snaps' or 'Add New Snap'. Here, search for 'EAS MetaMask Snap' or enter the URL provided by the EAS Snap host.

4. **Install the Snap**
Click on the 'Install' or 'Add to MetaMask' button next to the EAS MetaMask Snap listing. Follow any additional prompts to complete the installation.

5. **Grant Permissions** 
The Snap may request certain permissions to operate correctly. Review these permissions and grant them if you agree.

6. **Verify Installation**
Once installed, the EAS Snap should appear in your list of active Snaps within MetaMask. You can verify this by revisiting the 'Snaps' section.

7. **Update MetaMask If Needed** 
If you encounter any issues, ensure your MetaMask extension is updated to the latest version.

## Post-Installation
1. **Test the Snap:** 
Try signing an attestation transaction to see the EAS Snap in action. The attestation data should now be decoded and displayed in a readable format.

2. **Seek Support if Needed:** 
If you encounter issues or have questions, consult the EAS Snap documentation or reach out to the support team provided by the Snap developers.




================================================
FILE: docs/developer-tools/metamask-snap/metamask-snap.md
================================================
---
sidebar_position: 7
---

# EAS MetaMask Snap

The **EAS MetaMask Snap** enhances the transparency and security of EAS attestations signed with your MetaMask. It decodes attestation data, allowing users to clearly understand and verify the details before confirming a transaction.

## Why It Matters

When signing attestations with MetaMask, the data often appears in a hexadecimal format, which is not human-readable. The EAS Snap converts this data into a clear, readable format. This ensures you're fully aware of the attestation's details, mitigating the risk of unintentional or malicious signings.

## Key Features

- **Attestation Decoding:** Utilizes `SchemaEncoder` from the `@ethereum-attestation-service/eas-sdk` to decode attestation data, presenting it in a readable format.
- **Transaction Data Parsing:** The snap parses Ethereum transaction data to identify if it is related to an EAS attestation, using `ethers` library.
- **Dynamic Content Rendering:** It dynamically renders transaction details in the MetaMask UI, including schema, recipient, reference UID, expiration time, and revocability status, offering users a complete overview of the attestation they are about to sign.
- **Time Formatting:** Utilizes `dayjs` with extended formats to display expiration times in a user-friendly manner.
- **GraphQL Integration:** Communicates with EAS's GraphQL endpoint to fetch and display the schema associated with the attestation.
- **Data Decoding and Display:** Decodes and displays each piece of attestation data using the fetched schema, allowing users to understand the specifics of what they are attesting.

## Demo Video

This is a short demo video showing how the Snap works. Notice the hex value of the data first, then how the data is more readable when the 'EAS' snap is clicked.

<iframe width="560" height="315" src="https://www.youtube.com/embed/FdgzNyY10Fc" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

## Example

### Before Snap:

Signing an attestation in MetaMask shows data in hexadecimal format, leaving you unsure of what you're agreeing to.

![Hex Example](../img/hex-example.png)

### After Snap:

The same data is displayed clearly, with details like recipient, revocability, and schema easily understandable.

![Snap Example](../img/snap-example.png)



================================================
FILE: docs/easscan/_category_.json
================================================
{
  "label": "The Explorer",
  "position": 9,
  "link": {
    "type": "generated-index",
    "description": "Understand how to use the easscan explorer."
  }
}



================================================
FILE: docs/easscan/attestations.md
================================================
---
sidebar_position: 3
---

# No-Code Attestations
Want to make attestations without code? All you need is a wallet and some funds to pay for gas. Check out the steps below.

## How To Make An Attestation
Make sure you're on an explorer site of your choice. If you want to make a test attestation, we'd recommend using [**Sepolia**](https://sepolia.easscan.org/). 

1. Once you are on the Explorer, find the `Schema` you want to attest with. Want a quick option? Click on "Make Attestation" from the "Attestations" page. [**Here's a quick link for you on Sepolia**](https://sepolia.easscan.org/attestation/create).

2. Let's use the `Make a Statement` schema as our example.
- **Make a Schema:** [**https://sepolia.easscan.org/schema/view/0x3969bb076acfb992af54d51274c5c868641ca5344e1aacd0b1f5e4f80ac0822f**](https://sepolia.easscan.org/schema/view/0x3969bb076acfb992af54d51274c5c868641ca5344e1aacd0b1f5e4f80ac0822f)
![Make a Statement Schema](./img/make-a-statement-schema.png)

3. **Now that you're on the "Schema Record" page.** Click 'Make Attestation'. This will allow you to make an attestation with that schema. Notice that it decodes the schema data. For example, our `Make a Statement` schema is simply just a `string`. So in this no-code attestation maker, we can see `Message | string` decoded and we're allowed to type in a `string`.

![Make a Statement Attestation](./img/make-a-statement.png)

4. **Recipients are optional!** Not every attestation requires a recipient. Imagine posting something on social media, it's just a statement you're making. You don't need to reference someone or something even though you could.

:::tip Multiple Recipients
If you want to attest to multiple recipients, switch to onchain and it will allow you to add multiple recipients.
:::

![Multiple Recipients](./img/onchain-multirecipient.png)

5. **Additional Options:** This section will allow you to do a few special things:
 - Add an `expiration time`. Which sets a specific time when the attestation will expire.
 - Add a `Referenced Attestation UID`. This allows you to build [**modular and composable attestations**](/docs/core--concepts/composability.md).

 ![Additional Options](./img/advanced-options.png)

6. Now it's time to "Make Attestation"! You can choose between `onchain` or `offchain`. Curious to know the differences? You can [**learn more about the differences here**](/docs/core--concepts/onchain-vs-offchain.md). 

7. **Great!** You should now have an attestation record with a UID. Here's our onchain example:
 - [https://sepolia.easscan.org/attestation/view/0x3a847b3a63df89753afeb8a2a974a00161d3fac00e87a2bdf181e2297491b223](https://sepolia.easscan.org/attestation/view/0x3a847b3a63df89753afeb8a2a974a00161d3fac00e87a2bdf181e2297491b223)

 ![Onchain Example](./img/onchain-example.png)




================================================
FILE: docs/easscan/offchain.md
================================================
---
sidebar_position: 4
---

# Offchain Attestations
Offchain attestations offer a unique blend of privacy, efficiency, and flexibility. This tutorial will guide you through the process of creating peer-to-peer (P2P) offchain attestations using EASSCAN.org, and how to leverage them for various use cases.

## Creating an Offchain Attestation
- **Initiate the Attestation:** Navigate to the attestation creation section on EASSCAN.org.
- **Fill in the Details:** Just like creating an onchain attestation, select the schema UID and fill in the required fields.
- **Choose Offchain:** Once you've filled in the details, click on 'offchain attestation'. 
- **Click Make Attestation**: Now you can click "Make Attestation". It will trigger an `EIP-712`typed signature transaction for you to sign. No gas is required.

:::info Gas-Free & Private
Creating an offchain attestation requires only a digital signature from your wallet. It doesn't consume any gas, and since it's generated in the browser, even the server remains unaware of its existence. This ensures utmost privacy.
:::

## Sharing Your Offchain Attestation
With your offchain attestation created, you can:

- **Download the Data:** Save the attestation data for future reference or sharing. Store it in your own servers.
- **Download the QR Image:** A scannable QR code containing the attestation data, including the signature.
- **Share the Link**: Share the URL link of your attestation and share it peer-to-peer.

## Timestamping Onchain: Why and How?
While offchain attestations offer privacy and efficiency, they lack a verifiable timestamp from the network. This means you can't conclusively prove the exact time of the attestation's creation. However the UI allows you to:

1. Click on `timestamp onchain` near the timestamp section of your offchain attestation.
    - This action generates an onchain transaction, which you'll need to sign. It's a small `bytes32` transaction of the attestation `UID`, ensuring minimal gas costs.
2. With the timestamp now onchain, the attestation UID is a hash of the entire attestation data‚Äîserves as proof of the attestation's existence before a certain time.

:::tip Making it Public: Publish to IPFS
If you wish to make your offchain attestation more accessible, you can opt to Publish to IPFS. This action pins the attestation to IPFS, and EASSCAN indexes it, making it publicly viewable on the explorer. If you retain the attestation's private status, it remains invisible on the explorer.
:::

## Verifying Your Offchain Attestation
To ensure the integrity of an offchain attestation:

- Navigate to the tools section on EASSCAN.org.
- Upload the raw attestation data.
- The UI will decode it, allowing you to verify its authenticity and contents.

## Example
Here's an offchain attestation example we made on Sepolia. It's using the `Make a Statement` schema.
![Offchain Example](./img/p2p-attestation.png)

### URL
Here is the URL of the offchain attestation. The attestation data is completely encoded in the URI hash of the URL so it can be passed peer-to-peer.

[**https://sepolia.easscan.org/offchain/url/#attestation=eNqlUUuuEzAMvEvXFfLf8fK1pZdALBzHOQACieOTvgd7pOfFKLYzE4%2Fz7QJfyC5XRFQ9cL3A7zuZx7492JcKj3FvCX7i4%2BbKBA9iaxyofXldVhZYDgGW7TZnokbgzOFaMWHLFhaOJdtVdlAt7%2FbCnIqLCN5FzKsHlgDUtL08o2UvBnfIrnFkapn0ngtnt5DgKqHWDmDIqMuVxkunu23k13vf5C06NtNIseJ4KqzB%2Bw2Iox7Pj0cVa9JYa3QqpzNrjME8cFAOW8hVxcmZmIJnBI9Mt6Y6PY8P%2BxwWc4Jb1p4RlFtlKZJLaQ0bJlhHXaQxsxZM3Hq8DciCQbRfImf7FsLGbnSF98LPH7%2F6JQ%2BfCoJP8o%2BZYyH8fPtfxOMfbNsr%2BPTO5K%2BNEDiYmjrRcrF98F9%2BOC6nps4Hz%2Fkw9uHg%2F0x3OfvA738AgcWhrQ%3D%3D**](https://sepolia.easscan.org/offchain/url/#attestation=eNqlUUuuEzAMvEvXFfLf8fK1pZdALBzHOQACieOTvgd7pOfFKLYzE4%2Fz7QJfyC5XRFQ9cL3A7zuZx7492JcKj3FvCX7i4%2BbKBA9iaxyofXldVhZYDgGW7TZnokbgzOFaMWHLFhaOJdtVdlAt7%2FbCnIqLCN5FzKsHlgDUtL08o2UvBnfIrnFkapn0ngtnt5DgKqHWDmDIqMuVxkunu23k13vf5C06NtNIseJ4KqzB%2Bw2Iox7Pj0cVa9JYa3QqpzNrjME8cFAOW8hVxcmZmIJnBI9Mt6Y6PY8P%2BxwWc4Jb1p4RlFtlKZJLaQ0bJlhHXaQxsxZM3Hq8DciCQbRfImf7FsLGbnSF98LPH7%2F6JQ%2BfCoJP8o%2BZYyH8fPtfxOMfbNsr%2BPTO5K%2BNEDiYmjrRcrF98F9%2BOC6nps4Hz%2Fkw9uHg%2F0x3OfvA738AgcWhrQ%3D%3D)

### QR Code
You can save the `QR Code` and use it wherever you'd like. It has the entire attestation data, including the signature, gzipped and compressed.

![QR Code Example](./img/schema-7-attestation-1694364068.eas.png)

### Attestation Data
```javascript
{
   "sig":{
      "domain":{
         "name":"EAS Attestation",
         "version":"0.26",
         "chainId":11155111,
         "verifyingContract":"0xC2679fBD37d54388Ce493F1DB75320D236e1815e"
      },
      "primaryType":"Attest",
      "types":{
         "Attest":[
            {
               "name":"version",
               "type":"uint16"
            },
            {
               "name":"schema",
               "type":"bytes32"
            },
            {
               "name":"recipient",
               "type":"address"
            },
            {
               "name":"time",
               "type":"uint64"
            },
            {
               "name":"expirationTime",
               "type":"uint64"
            },
            {
               "name":"revocable",
               "type":"bool"
            },
            {
               "name":"refUID",
               "type":"bytes32"
            },
            {
               "name":"data",
               "type":"bytes"
            }
         ]
      },
      "signature":{
         "r":"0x5340d70906ae76bba15991ba875c9b0f4f43439d4f754f92cd7ee7c1ab51d220",
         "s":"0x67ce81c400cb6fd7a9e4fd30770aec8b0fcd64efbd1bee4241dc42e5e9030a9c",
         "v":28
      },
      "uid":"0x651cb28dd8ea53a7335988338182a86d13ccc3a3aa1a410fc79aa76e2c6d179e",
      "message":{
         "version":1,
         "schema":"0x3969bb076acfb992af54d51274c5c868641ca5344e1aacd0b1f5e4f80ac0822f",
         "recipient":"0x0000000000000000000000000000000000000000",
         "time":1694363762,
         "expirationTime":0,
         "refUID":"0x0000000000000000000000000000000000000000000000000000000000000000",
         "revocable":true,
         "data":"0x0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000002f5468697320697320616e206f6666636861696e2c20706565722d746f2d70656572206174746573746174696f6e21200000000000000000000000000000000000",
         "nonce":0
      }
   },
   "signer":"0xeee68aECeB4A9e9f328a46c39F50d83fA0239cDF"
}

```

## Wrapping Up
Offchain attestations on EASSCAN.org offer a powerful blend of privacy, efficiency, and flexibility. Whether you're looking to keep data private, share it selectively, or timestamp it for verifiability, the platform provides all the tools you need to control how you want to selectively share your attestation data.



================================================
FILE: docs/easscan/overview.md
================================================
---
sidebar_position: 1
---

# Easscan Overview
Welcome to the definitive guide for [EASSCAN.org](https://easscan.org), the explorer for the Attestation Ecosystem. Easscan.org is like the *"etherscan for attestation"*. It's your central hub and way for you to explore, discover, make, and verify schemas and attestations. 

![Easscan.org](./img/explorer-landing.png)

As a public good, our intention is to be as accessible to non-technical developers as we are to technical builders. Enjoy an experience that is exceptional compared to traditional explorers and let us know ways you'd like to see it improved!

:::info It's not an end-user tool
While we aim for the best DevEx, the easscan.org site is not intended to be an end user site for consuming or issuing attestation data. We encourage all builders to create amazing experiences on top of the attestation contracts for your own use cases.
:::

## Available Chains

| **Chain Type** | **Chain Name**      | **URL**                          |
|----------------|---------------------|----------------------------------|
| **Mainnets**   | Ethereum             | [https://easscan.org](https://easscan.org)             |
|                | Optimism            | [https://optimism.easscan.org](https://optimism.easscan.org)   |
|                | Base                | [https://base.easscan.org](https://base.easscan.org)         |
|                | Arbitrum One           | [https://arbitrum.easscan.org](https://arbitrum.easscan.org)   |
|                | Arbitrum Nova            | [https://arbitrum-nova.easscan.org](https://arbitrum-nova.easscan.org)   |
|                | Polygon          | [https://polygon.easscan.org](https://arbitrum-nova.easscan.org)   |
|                | Scroll          | [https://scroll.easscan.org](https://scroll.easscan.org)   |
|                | Linea          | [https://linea.easscan.org](https://linea.easscan.org)   |
| **Testnets**   | Sepolia             | [https://sepolia.easscan.org](https://sepolia.easscan.org)     |
|                | Optimism Sepolia     | [https://optimism-sepolia.easscan.org/](https://optimism-sepolia.easscan.org)   |
|                | Base Sepolia         | [https://base-sepolia.easscan.org](https://base-sepolia.easscan.org) |
|                | Polygon Mumbai         | [https://polygon-mumbai.easscan.org/](https://polygon-mumbai.easscan.org/) |
|                | Scroll Sepolia         | [https://scroll-sepolia.easscan.org/](https://scroll-sepolia.easscan.org/) |


## What You Can Do
There are several main things you can do with the explorer site. You are able to:
- **Explore schemas** that have been made on that chain and their activity
- **Inspect any attestation** made to an address or that an address has made
- Make schemas and attestations in a **no-code way** using our UI tools
- **Revoke** attestations you have made
- Make **batch attestations** to multiple recipients
- **Name schemas**, add **descriptions** and/or **context**
- Publish **offchain attestation to IPFS**
- **Timestamp offchain** attestations onchain
- **Verify** offchain attestations
- Make **private data attestations** allowing users to selectively disclose data
- And more!

## Community Collaboration
EASSCAN.org thrives on the insights and feedback of its users. As we continue to refine and expand our platform, we invite you to be an active participant in its evolution.

- **Feedback Loop:** Found a bug? Have a feature request? Or just general feedback? We're all ears. Your insights drive our improvements.
- **Open Discussions:** Join our community channels to discuss ideas, share your experiences, and collaborate with fellow innovators.
- **Stay Updated:** We're constantly rolling out updates. Stay in the loop and be the first to test out new features.

Remember, EASSCAN.org is more than just a tool; it's a community-driven platform aiming to redefine the attestation landscape. Your voice matters, and together, we can shape the future of the attestation ecosystem.


## Ready to get started?
Learn more about the explorer in the following pages.





================================================
FILE: docs/easscan/schemas.md
================================================
---
sidebar_position: 2
---

# No-Code Schema Building
Creating schemas doesn't require a deep dive into code. With EASSCAN's intuitive UI, you can craft your own schema **without writing a single line**. This guide will walk you through the process, ensuring you can harness the power of attestations, even if you're not a developer.

![Create Schema](./img/create-schema.png)

## Getting Started
1. **Access the Schema Builder:** Navigate to https://sepolia.easscan.org/schema/create on your desired chain (change our sepolia for your chain name where easscan is deployed)

2. **Craft Your Schema:** The no-code schema builder will present you with a user-friendly interface. Here, you can:
- Add schema fields.
- Select a type for each field.
- Organize fields in your preferred order.

:::tip Schema Tips
While building your schema, consider visiting the "schemas" page to deepen your understanding of schemas. For those looking to optimize, the "how to make gas efficient schemas" tutorial is a must-read.
:::
- **Read More:** [**Schemas**](/docs/core--concepts/schemas.md)
- **Read More:** [**Gas Efficient Schemas**](/docs/tutorials/gas-efficiency.md)

3. **Resolver Contract (Optional):** This option allows your schema to interact with specific smart contracts to resolve or verify data. Not sure what this means? Learn more about resolver contracts in the dedicated section.

4. **Revocability:** Decide if you want attestations to be revocable:
 - **Revocable:** Attestations made with this schema can be revoked by the entity that created them.
- **Non-Revocable:** Attestations are permanent and cannot be undone.

5. **Make the Schema:** Once you're ready with your schema, click `create schema`. This will trigger a transaction to register your schema and give you a `UID`, making it ready for attestations. You'll see it registered on the Schemas page of the explorer.

## Enhancing Your Schema
After registering your schema, you can add layers of context and relevance:

- **Name A Schema:** Give your schema a recognizable name. [**Learn how**](/docs/tutorials/naming-your-schema.md).
- **Schema Description:** Provide a detailed description to explain the purpose and use of your schema. [**Here's a tutorial**](/docs/tutorials/schema-description.md).
- **Schema Context:** Link your schema to standardized definitions, like those on schema.org, to provide universal clarity. [**Find out more**](/docs/tutorials/schema-context.md).

Each of these enhancements is achieved through [**referenced attestations**](/docs/core--concepts/composability.md) to the schema's UID, ensuring a modular and flexible approach.

## Wrapping Up
EASSCAN empowers both technical and non-technical builders to be a part of the attestation ecosystem. The no-code tools will allow anyone to create, enhance, and manage schemas with ease. Dive in, explore, and remember: every great product starts with a well-defined schema.








================================================
FILE: docs/easscan/utilities.md
================================================
---
sidebar_position: 5
---

# Extended Utilities
You can do so much with your Schemas and Attestation Data. We've been building a few ways to extend the functionality of a few schemas within the EASSCAN UI.

:::tip Have a good idea?
Share it within our community channels, like [Telegram](https://t.me/+EcynOr0iFu03MTYx).
:::

## Unique Features & Extended UIs
Here's our growing list of unique features and UI's we've extended to improve the user experience.

### Content & Document Hashing
Easily hash any file and attest to it. There are two schemas you can use for this:
- **Content Hash**: Allows you to generate a hash of any file type and attest to it. [**Learn more about this feature**](/docs/developer-tools.md/hash-a-file.md).
    - **Example Schema:** [https://sepolia.easscan.org/schema/view/0xdf4c41ea0f6263c72aa385580124f41f2898d3613e86c50519fc3cfd7ff13ad4](https://sepolia.easscan.org/schema/view/0xdf4c41ea0f6263c72aa385580124f41f2898d3613e86c50519fc3cfd7ff13ad4)
- **Sign Document**: 
    - **Example Schema:** [https://sepolia.easscan.org/schema/view/0xd3f24e873e8df2d9bb9af6f08ea1ddf61f65754d023f3ea761081e3e6a226a80](https://sepolia.easscan.org/schema/view/0xd3f24e873e8df2d9bb9af6f08ea1ddf61f65754d023f3ea761081e3e6a226a80)
    - **Example Attestation:** Here's an example hash and signature attesting to the authenticity of the `Ethereum Whitepaper`. 
    
    ![Ethereum Whitepaper](./img/ethereum-whitepaper-hash-verified.png)

### Private Data Attestations
Attest to the merkle root of a bunch of private data. This can be useful for attesting to an `allowlist` of users, selective information or private info. The `merkle root` is attested to onchain and then you can selectively share each of the individual merkle tree leaves, effectively selectively disclosing the information, and allowing others to verify that that piece of data was indeed a part of the merkle tree. The value comes from the entity that attested to the private data merkle root, and then allowing others to verify the data.

**Tutorial:** [Private Data Attestations](/docs/tutorials/private-data-attestations.md)

![Private Data Attestation](./img/private-data-attestation-example.png)

:::info Want to read more?
Check out our [**Mirror Article**](https://mirror.xyz/0xeee68aECeB4A9e9f328a46c39F50d83fA0239cDF/BiFUEFJKo6ZsIvPwsP9WPC2UZX0-x_9BdtrvmQo1FwY) on `Private Data Attestations Using Merkle Trees`
:::

#### Example Private Data
**Attestation Record:** [https://sepolia.easscan.org/attestation/view/0x8c47c30523966364dece9024b7f7ed5d3c93a7952b1e58d03e4da52d74da80e8](https://sepolia.easscan.org/attestation/view/0x8c47c30523966364dece9024b7f7ed5d3c93a7952b1e58d03e4da52d74da80e8)

**Example Proof:** If you'd like to follow along, copy the proof below and verify it on the attestation record above.
```javascript
{"leaves":[{"type":"bool","name":"isOver21","value":true,"salt":"0x9a7e8887f01b35b2795464a7f3ddc325c9a913f92505f92338cde24edf866d4e"}],"proof":["0x8a38a3864c340eb958f180f43124748ceb65f6b663af40f771d2a99fd15ae323"],"proofFlags":[false]}
```

### Verifying Offchain Attestations
Upload any offchain attestation raw data into this tool so you can easily see if it's a valid offchain attestation.

**Tutorial:** [Verify Offchain Attestations](/docs/developer-tools/verify-attestation)

![Verify Offchain Attestation Container](./img/verify-offchain.png)

### Timestamping Offchain Attestations
Offchain attestations do not have a verifiable timestamp. If you want to timestamp multiple `UID`s of the offchain attestation, it will generate a merkle root and timestamp just that root. Then you can verify any of the individual UIDs.

**Tutorial:** [Timestamping Offchain](/docs/developer-tools/verify-timestamp)

![Offchain Timestamp UIDs](./img/offchain-timestamp-uids-container.png)

### Land Registry
This was a fun project we built to show how different UIs can be extended on the schema record. For example, this schema takes an array of polygon points and allows you to attest to the parcel of land. This obviously would be an important attestation if it came from a land registrar. Once attested, you can see how the attestation data is displayed in a unique way.

Here's an example of the Capitol Building in Colorado, USA.

![Land Registry Example](./img/land-registry-example.png)

### Devfolios Quadratic Voting System
Kudos to the [**Devfolio**](https://devfolio.co/discover) team! They built a unique `Quadratic Voting System` for their hackathon. It allowed the community to cast their votes on the projects they believe deserve the prize pool. Each attestation was a record of the users votes to ensure transparency. 

**Read More:**:[**Introooducing Quadratic Voting:**](https://devfolio.co/blog/introooducing-quadratic-voting-on-devfolio/)

Example attestation on Arbitrum: [https://arbitrum.easscan.org/attestation/view/0xe046453fd6f92921c1b4ece997c02d5271339f00f14850608a64455d8648ad36](https://arbitrum.easscan.org/attestation/view/0xe046453fd6f92921c1b4ece997c02d5271339f00f14850608a64455d8648ad36)

![Quadratic Vote](./img/quadratic-vote-example.png)



================================================
FILE: docs/idea--zone/_category_.json
================================================
{
  "label": "Ideas to Build",
  "position": 10,
  "link": {
    "type": "generated-index",
    "description": "Get inspired on what to build."
  }
}



================================================
FILE: docs/idea--zone/thought-starters.md
================================================
---
sidebar_position: 1
---

# Thought Starters
The Attestation Ecosystem is quickly becoming the next frontier for builders and innovators. But where do you start? How should you be thinking about your products and where attestations fit in? How do you help others with the power of attestations? This quick guide will help ideate and brainstrom the themes, trigger words, and ways to start innovating with attestations.

## Trigger Words
When you're thinking about your own use cases, think about the following `trigger words`. They're usually a good indication that an attestation would be valuable here.
- **Verifying:** Confirming the authenticity of a product or the accuracy of information.
- **Vouching:** Endorsing someone's skills, experience, or character.
- **Voting:** Recording preferences or decisions in elections or community polls.
- **Proving:** Demonstrating ownership of assets, completion of tasks, or attainment of milestones.
- **Authenticating:** Establishing the genuineness of an item, artwork, or collectible.
- **Certifying:** Validating completion of courses, training, or adherence to standards.
- **Endorsing:** Publicly supporting or recommending a product, service, or individual.
- **Validating:** Confirming the legitimacy of a claim, be it health records, financial status, or any other data.
- **Recording:** Keeping a digital note of events, achievements, or incidents.
- **Witnessing:** Attesting to the occurrence of an event, action, or decision.
- **Guaranteeing:** Assuring the quality, durability, or performance of a product or service.
- **Declaring:** Making a formal or official statement about a fact, intention, or belief.
- **Confirming:** Corroborating an event, transaction, or activity.
- **Securing:** Ensuring the safety, privacy, or confidentiality of data or actions.
- **Identifying:** Establishing the identity or characteristics of an individual, organization, or item.

## Thought-Provoking Questions
- **Verification:** How might we eliminate fraud in our own product experiences? What types of verifications would be helpful?
- **Governance:** How can attestations ensure transparency and accountability in our decision-making processes?
- **Compliance:** Could attestations automate and simplify our compliance, ensuring every stakeholder's data is verified?
- **User Trust:** How might we bolster user trust by verifying the credentials of sellers or content creators?
- **Efficiency:** Where do manual verification processes slow us down? How can attestations streamline this?
- **Monetization:** Could attestations enable new revenue streams, like verified premium listings or services?
- **Interoperability:** How can attestations help our product integrate with other platforms, creating a unified ecosystem?
- **User Experience:** Can attestations reduce user steps by auto-filling verified data, enhancing their experience?
- **Risk Management:** Where are we exposed due to unverified data? How can attestations mitigate these risks?
- **Global Reach:** How can attestations ensure credentials from one region are verified and accepted globally?

## Engage with the Community
Got an idea? Share it! Our community channels are full with enthusiasts, experts, and fellow innovators. Posting your ideas can provide you with:

- Early feedback to refine and improve your concept.
- Connections with potential collaborators or partners.
- Insights into challenges or opportunities you might not have considered.
- A platform to showcase your innovation and gain early adopters.

Remember, innovation thrives in a collaborative environment. Engage, share, learn, and iterate. The Attestation Ecosystem is vast, and there's room for everyone to make a mark. Dive in, and let's build the future together!



================================================
FILE: docs/idea--zone/when-to-use-eas.md
================================================
---
sidebar_position: 3
---

# When To Use Attestations
Attestations help us build more trustful interactions online. They can be used as credentials, forms of verifications, proof of something happening or not happening, ensure the integrity or authenticity of something, and much more. But when is the right time to use attestations via EAS?

## Existing Alternatives
As builders, I'm sure you've seen the surge in using NFTs and Soulbound Tokens (SBTs) for various types of attestations. Whether it's a credential being issued for access into a community or skill being achieved or other. These are simply just entities saying something about something or someone. But are NFTs and SBTs the best tools for the job? Or are we just defaulting to what we have available? What if there was something better?

:::warning Avoid the trap
"When you have a hammer, everything looks like a nail." - Abraham Maslow
:::

NFTs revolutionized digital assets, but they falter when used as credentials due to their transferability and lack of interoperability. Enter SBTs, an upgrade with non-transferability and revocability. But even SBTs lack a universal standard. Each SBT is a unique contract with no consistent data structure, making integration a developer's nightmare. Let's stop trying to upgrade the "hammer" when you actually need a new tool altogether.

:::tip Challenge your thinking
Is an NFT or an SBT the best solution, or is an attestation more apt?
:::

## Devs
Frustrated with inconsistent digital signatures, non-interoperable platforms, and unreliable centralized databases? Attestations offer:
- **Unified Integration:** A standard for all verifications, cutting down on multiple API integrations.
- **Data Integrity:** Assurance that shared data remains untampered.
- **Interoperable Solutions:** Compatibility across platforms, dapps, and services.
- **Schema Registry:** A structured data approach for easy categorization and verification.

**Attestation Triggers:**
Integration, Data Consistency, Interoperability, Structure, Standardization, Compatibility, Security, Privacy

## Non-Technical Builders
Want a quick way to verify content, check member credibility, or ensure process compliance without centralized systems? Attestations can be your answer:
- **Content Verification:** Check the originality of content, from articles to reviews.
- **Community Trust:** Verify the authenticity of community members and their contributions.
- **Access Control:** Control access based on verified attributes.
- **Reputation Systems:** Create a reputation system where positive actions earn attestations.

**Trigger Words:**
Authenticity, Verification, Trustworthiness, Access Control, Reputation, Compliance, Credibility, Interoperability

## Users
Tired of repeatedly proving your identity or achievements on new platforms? Not sure who or what to trust online? Attestations can elevate your online journey:
- **Universal Recognition:** Use a single attestation across platforms.
- **Showcasing Achievements:** Display your achievements, from courses to community contributions.
- **Trust in Interactions:** Interact confidently, knowing others and/or content are verified.
- **Personal Control:** Choose who sees your attestations with offchain attestations, private data attestations, or zkps from attestation data.

**Attestation Triggers:**
Recognition, Achievements, Trust, Control, Verification, Privacy, Security

This refined content provides a concise yet comprehensive overview of when and why to use attestations, emphasizing the moments when they should consider using or verifying attestations.



================================================
FILE: docs/idea--zone/use--case--examples/_category_ 2.json
================================================
{
  "label": "Example Use Cases",
  "position": 1,
  "link": {
    "type": "generated-index",
    "description": "Get inspired on what to build."
  }
}



================================================
FILE: docs/idea--zone/use--case--examples/_category_.json
================================================
{
  "label": "Example Use Cases",
  "position": 1,
  "link": {
    "type": "generated-index",
    "description": "Get inspired on what to build."
  }
}



================================================
FILE: docs/idea--zone/use--case--examples/carbon-credits 2.md
================================================
---
sidebar_position: 21
---
# Carbon Credits

## Problem
Carbon credits are a key tool for reducing greenhouse gas emissions, as they provide an economic incentive for businesses to reduce their carbon footprint. However, the carbon credits market has faced significant challenges due to a lack of transparency and accountability in the issuance and trading of carbon credits. This has led to concerns about the reliability and effectiveness of the market, and has hindered the adoption of carbon credits as a viable tool for reducing greenhouse gas emissions.

## Opportunity
The use of attestations in carbon credits provides a more transparent and trustworthy market. It enables greater compliance and proof of proper issuance of carbon credits. By using attestations, it is possible to create an immutable record of carbon credit issuance, transfer, and retirement, ensuring that each carbon credit has a clear and transparent history. This leads to a more trustworthy and decentralized carbon credits market.

## Example
Let's say that a company wants to issue carbon credits for reducing their greenhouse gas emissions. They can use attestations to provide proof of their emissions reductions by having an independent third-party auditor attest to their emissions data. This attestation can then be added to the blockchain, creating an immutable record of the company's emissions reductions.

When the carbon credits are sold on a decentralized marketplace, each credit can be represented by an attestation that includes information about the issuer, the date of issuance, and the emissions reduction that the credit represents. Buyers of the credits can then verify the authenticity of the credits by checking the attestations on the blockchain.


## Sample Schema
This is an example carbon credit being attested to. It would come from a carbon credit authority address and be issued to the beneficiary address of the carbon credit. It would include a value of the carbon credits issued, the date it was issued, and a hash of the evidence provided.

```jsx
uint256 carbonCredits
uint64 issuanceDate
bytes32[] evidenceHash
```

## Future Composability
As more organizations adopt attestations for carbon credits issuance and trading, it will become possible to create a more interconnected and efficient carbon credits market. By standardizing the schema for carbon credit attestations, it will be possible to create a decentralized carbon credits market that spans multiple issuers and trading platforms. This will enable greater liquidity and transparency in the market, and make it easier for organizations to participate in the market and achieve their emissions reduction goals.


================================================
FILE: docs/idea--zone/use--case--examples/carbon-credits.md
================================================
---
sidebar_position: 21
---
# Carbon Credits

## Problem
Carbon credits are a key tool for reducing greenhouse gas emissions, as they provide an economic incentive for businesses to reduce their carbon footprint. However, the carbon credits market has faced significant challenges due to a lack of transparency and accountability in the issuance and trading of carbon credits. This has led to concerns about the reliability and effectiveness of the market, and has hindered the adoption of carbon credits as a viable tool for reducing greenhouse gas emissions.

## Opportunity
The use of attestations in carbon credits provides a more transparent and trustworthy market. It enables greater compliance and proof of proper issuance of carbon credits. By using attestations, it is possible to create an immutable record of carbon credit issuance, transfer, and retirement, ensuring that each carbon credit has a clear and transparent history. This leads to a more trustworthy and decentralized carbon credits market.

## Example
Let's say that a company wants to issue carbon credits for reducing their greenhouse gas emissions. They can use attestations to provide proof of their emissions reductions by having an independent third-party auditor attest to their emissions data. This attestation can then be added to the blockchain, creating an immutable record of the company's emissions reductions.

When the carbon credits are sold on a decentralized marketplace, each credit can be represented by an attestation that includes information about the issuer, the date of issuance, and the emissions reduction that the credit represents. Buyers of the credits can then verify the authenticity of the credits by checking the attestations on the blockchain.


## Sample Schema
This is an example carbon credit being attested to. It would come from a carbon credit authority address and be issued to the beneficiary address of the carbon credit. It would include a value of the carbon credits issued, the date it was issued, and a hash of the evidence provided.

```jsx
uint256 carbonCredits
uint64 issuanceDate
bytes32[] evidenceHash
```

## Future Composability
As more organizations adopt attestations for carbon credits issuance and trading, it will become possible to create a more interconnected and efficient carbon credits market. By standardizing the schema for carbon credit attestations, it will be possible to create a decentralized carbon credits market that spans multiple issuers and trading platforms. This will enable greater liquidity and transparency in the market, and make it easier for organizations to participate in the market and achieve their emissions reduction goals.


================================================
FILE: docs/idea--zone/use--case--examples/content-authenticity.md
================================================
---
sidebar_position: 7
---

# Content Authenticity

## Problem
In the field of journalism, ensuring the authenticity and accuracy of digital content has become increasingly challenging due to the rise of AI-generated content, misinformation, and misrepresentation. Traditional methods of verification, such as fact-checking and source-verification, are becoming less effective and unable to keep up with the scale of the problem. This undermines the trust in journalism and the credibility of the content.

## Opportunity
Attestations can provide a secure, transparent, and immutable way to verify the authenticity and accuracy of digital content. By creating verifiable claims about the origin, ownership, and authenticity of a piece of content, we can create a reputation system that is resistant to manipulation and fraud. This will allow individuals and organizations to authenticate the parties they are dealing with and to restore trust in online content. With the use of blockchain-based attestations, we can ensure that the integrity and authenticity of online content are maintained, providing a foundation for trust in the digital age.

## Example
A media company wants to ensure that their articles are authentic and that their readers can trust the information provided. To do this, the journalists create an attestation that references a hash of their article, creating a unique identifier (UID) for that attestation. The editor-in-chief of the media company then makes an attestation that references the journalist's UID, attesting that the article was approved for publication by the media company. Once the article is published, readers can also make attestations to the validity and accuracy of the content. This provides additional layers of verification and helps to establish trust in the information being provided.

## Sample Schema
It includes two fields: `contentHash`, which is a hash of the content being attested to, and `urlOfContent`, which is the URL where the content can be found. This schema can be used as a basis for creating attestations that verify the authenticity of digital content, such as articles, videos, or images.

```jsx
bytes32 contentHash,
string urlOfContent
```

## Future Composability 
With the use of attestations for content authenticity, we can create a reputation system for digital content creators, which can help to combat misinformation, fraud, and forgery. This can be extended to other industries, such as finance, healthcare, and education, where verifiable claims can be used to prove identity, credentials, and history. By building a decentralized ledger of attestations, we can ensure that the integrity and authenticity of online content are maintained, providing a foundation for trust in the digital age.





================================================
FILE: docs/idea--zone/use--case--examples/credentials.md
================================================
---
sidebar_position: 2
---

# Digital Credentials

## Problem
The current digital credentialing and badge building platforms in both Web3 and Web2 create fragmentation in the ecosystem, as there is no unified base layer for attestations. Each platform has its own method of credentialing, which leads to a complex and confusing landscape for developers and users alike. Additionally, current credentialing systems can be vulnerable to fraud and inaccuracies, leading to a lack of trust in the credentials themselves.

## Opportunity
EAS provides a base layer for digital credentials, allowing anyone to create or integrate credentials with ease. EAS's flexible schemas can be used to create credentials of any type and have them issued on or off-chain, while ensuring the authenticity, non-transferability, revocability, expirability, immutability, transparency, composability, versatility, interoperability, and batchability of each attestation.

Attestations can be used to verify a wide range of information, such as identity, employment history, academic achievements, financial data, and roles and authorizations. The use of attestations provides a more secure and trusted way to verify information, leading to increased trust in the credentials themselves and the organizations issuing them. The value of the attestation comes from the attestor, not the schema or the badge.

## Example
A dev completes a certificate course in Advanced Solidity from a reputable school. The school issues an attestation to the dev's wallet, verifying that they have completed the course and have a deep understanding of Solidity. The attestation is recorded on-chain ensuring its immutability and authenticity. By having this attestation tied to their digital identity, the dev can easily share their verified credentials with potential employers or other parties without having to go through time-consuming and unreliable verification processes.

### Sample Schema
```jsx
bytes32 courseID
string courseName
uint64 completionDate
```

Every attestation made with the EAS contracts will include the following:
- UID - the autogenerated unique universal identifier that‚Äôs a hash of the attestation
- Timestamp - when it was created
- Attester - who made the attestation
- Recipient - the address the attestation was about (if relevant)
- Attestation data - the information of the attestation
- Reference UID - the UID of the related attestation (if any)
- Expiration time (optional) - the time the attestation expires
- Revocation time (optional) - the status and date if attestation was revoked
- Resolver - an optional contract that can be triggered from the schema once the attestation is made

EAS provides a flexible and powerful framework for creating digital credentials that can be W3C compliant but also future-proof and efficient. With EAS, you can create customizable schemas that reflect your unique use case, and even explore new standards around digital credentials that are more suited to blockchain-based solutions.

## Getting Started
To start using EAS, simply install the SDK, create your own schema, and begin issuing and verifying credentials. The SDK handles all the heavy lifting, so you can focus on building your application. We also have extensive documentation and resources to help you along the way.

### Wanting to read a bit more? 
- Check out our recent article [The Future of Verifiable Credentials: Beyond ERC-721 & SBTs](https://mirror.xyz/0xeee68aECeB4A9e9f328a46c39F50d83fA0239cDF/K63khDZank5wrfzCulDq5R6dfN2m4zGanO5lsAxfg-w)


================================================
FILE: docs/idea--zone/use--case--examples/digital-identity.md
================================================
---
sidebar_position: 1
---

# Digital Identity

## Problem
Digital identity has been a long sought after challenge to solve. The industry has been building siloed and centralized identity solutions, but the problem is that they are often built one layer too high. Identity is not a single, fixed thing that can be presented in a static way. Rather, identity is an aggregation of different aspects of an individual's life, such as their relationships, roles, achievements, and more. These different aspects are represented through various attestations made by different entities, such as family members, employers, governments, and other organizations.

The challenge is that there is currently no base layer for any entity to make attestations about anything. Without a standardized and open platform for creating and verifying attestations, identity solutions will continue to be fragmented and incomplete. This results in a lack of trust and interoperability between different identity solutions, making it difficult for individuals to manage their identity in a decentralized and secure way and makes increasingly tedious and difficult for a developer to manage all the integrations.

## Opportunity
To truly form identities like how it works in the physical world, we need to create a standardized and decentralized platform that allows entities to make attestations about each other. Such a platform would provide a common framework for creating and verifying attestations and enable the aggregation of these attestations into a complete digital identity.

A base layer for attestations would allow different organizations and services to provide attestations about different aspects of a person's life, such as education, work history, and other credentials. Individuals would then be able to aggregate these attestations into a single identity that they could use across multiple services and applications.

This approach would enable digital identity to be more flexible, customizable, and context-dependent, reflecting the multi-dimensional nature of identity in the physical world. By providing a shared platform for attestations and digital identity, we can enable a new generation of reputation systems, personalized experiences, and secure and privacy-preserving digital interactions.

## Let's explore an example
Alice has a digital identity that is composed of attestations made by different entities. She has an attestation from her friends that she is trustworthy and kind, an attestation from the government that she is a citizen and holds a driver's license, and an attestation from her employers that she has certain skills and experience in her field.

These different attestations form the basis of her digital identity, which she can use to authenticate herself to various services and applications. For example, she can use her driver's license attestation to prove her identity when renting a car, and she can use her work attestation to prove her skills when applying for a job.

Over time, Alice's digital identity can grow and change as she accumulates more attestations from different entities. This enables her to have a more complete and nuanced digital representation of herself, which can be used across a wide range of services and applications.

## Taking a Privacy First Approach
:::danger Developers must take a privacy-first approach
:::

EAS does not presuppose which privacy-preserving technology is best for any use case. However, the privacy of individuals must be a top priority.

The privacy of individuals must be a top priority. For example, instead of a government attesting to someone's entire passport data, the government or identity service would only need to attest to a hash of the passport document and its expiration date. 

Similarly, for a KYC compliance, the KYC service would only need to attest to a true/false flag that shows that the address successfully passed their KYC compliance process. It wouldn't need to store any information beyond that.

EAS also allows users to create [Private Data Attestations](/docs/tutorials/private-data-attestations). `Private Data Attestations` take advantage of Merkle Trees' unique capabilities to selectively disclose specific data fields without compromising overall privacy. This innovative feature allows users to create attestations with a single "private data" field, which contains the hash of a Merkle tree root. As a result, users can securely store and share particular parts of their attested data while preserving their privacy.

Attestations with `Zero Knowledge Proofs` are another path forward to explore. 

## Sample Schema
This is a sample schema for a digital identity card, similar to a driver's license. The schema includes fields for the individual's name, date of birth, address, photo hash, and license number. However, the power of EAS is that the schema can be customized to include any relevant information for the individual's digital identity, and even include a resolver contract for more versatility and control of how the schema is used.

:::tip Tip
This schema should be made off-chain or with privacy preserving technologies.
:::

```jsx
string name,
uint64 dateOfBirth,
bytes32 address,
bytes32 photoHash,
bytes32 licenseNumber
```
- `name`: A string value representing the name of the person.
- `dateOfBirth`: A unix timestamp value representing the date of birth of the person.
- `address`: A bytes hash representing the address of the person.
- `photoHash`: A bytes hash representing the hash of the photo of the person.
- `licenseNumber`: A string value representing the license number of the person.

## Future Composability
One of the major benefits of creating a standardized platform for digital identity and attestations is that it enables future composability. This means that different attestations can be combined and used together to provide more powerful and contextualized identity solutions.

As more entities make attestations and contribute to an individual's digital identity, the identity becomes more powerful and useful. Individuals can use their digital identity to authenticate themselves to different services and applications, while organizations can use the identity to make more informed decisions about their customers or employees.

Creating a standardized and decentralized platform for digital identity and attestations is a complex task, but the potential benefits are immense. By providing a common framework for creating and verifying attestations, we can enable a more trustworthy and interoperable digital world.



================================================
FILE: docs/idea--zone/use--case--examples/digital-notary.md
================================================
---
sidebar_position: 11
---

# Digital Notary

## Problem
Traditional notarization can be a time-consuming and expensive process, often requiring in-person appointments and multiple copies of documents. It can be challenging for individuals and businesses to complete this process quickly and efficiently, especially when working with documents from different regions or countries.

## Opportunity
A digital notary service can provide an innovative solution to this problem by allowing individuals and businesses to notarize documents remotely. By leveraging blockchain-based attestations, users can create immutable and tamper-proof records of their documents, which can be verified instantly by anyone, anywhere in the world.

## Example
John needs to notarize a contract for a business deal with a partner in another country. Instead of flying to the partner's location or hiring a local notary, John uses a digital notary service.

John uploads the contract to the digital notary service, which generates a cryptographic hash of the document and stores it on the blockchain. The digital notary service then issues a timestamped and signed attestation, which confirms the authenticity of the document.

John's partner can then verify the certificate and document hash to ensure that the contract is legitimate and unchanged. This process provides John and his partner with an efficient and secure way to notarize their contract, without the need for in-person appointments or expensive travel.

## Sample Schema
The Digital Notarization schema consists of `documentHash` and `documentID`. The documentHash is a cryptographic hash of the notarized document, which is stored on the blockchain for secure verification. The documentID is a unique identifier associated with the notarized document. This schema provides an efficient and secure way to notarize documents, eliminating the need for physical presence and offering a decentralized alternative to traditional notarization services.

```jsx
bytes32 documentHash
bytes32 documentID
```

## Future Composability
As the attestation ecosystem grows, the digital notary service could be integrated into various workflows where document verification is needed. For instance, it could be used in the mortgage and real estate industry to verify the authenticity of property deeds, in the legal industry to validate contracts and agreements, and in the healthcare industry to verify patient consent forms. By leveraging the power of blockchain and cryptographic hashes, the digital notary service can provide a secure and efficient way to verify the authenticity of important documents, saving time and money while reducing the risk of fraud or tampering.





================================================
FILE: docs/idea--zone/use--case--examples/healthcare-records.md
================================================
---
sidebar_position: 17
---
# Healthcare Records

## Problem
One of the main issues with healthcare records is the lack of interoperability between Electronic Health Record (EHR) systems. This can result in delays in treatment, duplication of efforts, and increased healthcare costs. In addition, healthcare records contain highly sensitive personal information that must be kept secure and private.

## Opportunity
Blockchain technology can provide a secure and private solution for healthcare records. By using zero-knowledge proofs and attestations, individuals can selectively disclose their personal information to healthcare providers without revealing their entire medical history. This ensures privacy and security for sensitive health data.

Attestation-based healthcare records can also improve interoperability by creating a decentralized system where healthcare providers can access patient records instantly, no matter where they are located.

## Example
A patient visits their healthcare provider and receives a diagnosis. The provider creates an attestation on the patient's healthcare record using private data attestations to ensure that only the necessary information is disclosed. The patient can then selectively disclose their healthcare records to other healthcare providers as needed, ensuring privacy and security for their personal information.

Attestation-based healthcare records can also be used to track medication adherence, enabling healthcare providers to monitor patient compliance with medication regimens and make adjustments as needed. This can improve patient outcomes and reduce healthcare costs.

## Taking a Privacy First Approach
:::danger Developers must take a privacy-first approach
:::
EAS does not presuppose which privacy-preserving technology is best for any use case. However, the privacy of individuals must be a top priority. 

EAS also allows users to create [Private Data Attestations](/docs/tutorials/private-data-attestations). `Private Data Attestations` take advantage of Merkle Trees' unique capabilities to selectively disclose specific data fields without compromising overall privacy. This innovative feature allows users to create attestations with a single "private data" field, which contains the hash of a Merkle tree root. As a result, users can securely store and share particular parts of their attested data while preserving their privacy.

Attestations with `Zero Knowledge Proofs` are another path forward to explore. 


## Sample Schema

```jsx
bytes32 patientID
bytes32 diagnosis
uint64 dateOfTreatment
bytes32 evidenceHash
```

## Future Composability
The attestations-based healthcare record system can be extended to include other types of health data, such as medical images, lab results, and medication histories. Additionally, the system can be integrated with other blockchain-based systems, such as medical billing and insurance, to provide a more comprehensive view of an individual's healthcare information. This composability enables healthcare providers to create a more secure, efficient, and interconnected system of healthcare management.


================================================
FILE: docs/idea--zone/use--case--examples/land-registries.md
================================================
---
sidebar_position: 14
---

# Land Registry 

## Problem
Land ownership in many parts of the world are based on antiquated government systems. In some places, land records are even still stored on paper registries!

## Opportunity
EAS can enable a global, standardized trust layer for governments and citizens that powers verifiable land ownership registries. Using blockchain-based attestation services, governments can digitize land registries, providing a secure and efficient way to prove ownership of a plot of land. By using attestation services to verify land ownership and transfer, the process can be streamlined, reducing the risk of errors and fraud.


## Example schema 
Using EAS, governments can attest to the ownership of land. 

The schema may have `3` properties:
```bash 
bytes polygonArea, uint8 landType, uint24 expiry 
```
- **bytes polygonArea** - A set of GPS coordinates that defines the verticies of the land (a closed polygon space)
- **uint8 landType** - Defines if the land is free-hold (0), lease-hold (1), or other (2)
- **uint24 expiry** - If the land is lease-hold, the expiry date of the land deed


## Example attestation
Here is an example attestation record: [0x0f41ffcf00a7b8d3e3a1c934083fb7e6733d74190eb0668399aa81c3c68428f3](https://sepolia.easscan.org/attestation/view/0x0f41ffcf00a7b8d3e3a1c934083fb7e6733d74190eb0668399aa81c3c68428f3) attesting that an address `0xA9c1f68A8003209aAc228001c175ca688ef0E503` owns some a land.


- `bytes polygonArea` [[4068886000,-7404463000],[4069003000,-7404721001],[4069101000,-7404669000],[4069065000,-7404429000],[4068976000,-7404326000],[4068872000,-7404360000]]
(**4** GPS coordinates defining a rectangle)
- `landType`: 1 (1 is for lease-hold)
- `expiry`: 0 (unix timestamp of the lease-hold expiry date)


If you plot this polygon on a map you‚Äôll see the piece of land it encloses. And if you check the attestor address, you‚Äôll see the Authority who attested to it.


## Future composability
:::info Thinking for the future
How can this evolve as EAS grows?
How can this be composed with other attestations?
:::

#### Land ownership in the future
- Land and property can be bought and sold **ON-CHAIN**. 
- Property and land can be tokenized as NFT‚Äôs and ownership details `attested` to. 
- Governments can `attest` to the new owner of any land once the NFT is sold or transferrerd.  
- A smart contract that handles the sale of the property NFT would need to meet all the `attestation` requirements that a government demands in order to be valid.   
- Once the governemnt `attests` to the validity of the sale, Funds could be a released from the Buyer to Seller automatically, and a portion could be transfer taxes to the government. 

#### Improving the mortgage process
`Attesations` can also help buyers and lenders to create a more competitive and trasnsparent mortgage market. Let‚Äôs think of a future example where **Bob** wants to buy some land, but needs a mortgage.

He can collect the following `attestations` from trusted providers which would be useful to help him buy the land title **ON-CHAIN**

```bash
1. Identity (Schema #111)
2. Credit score (Schema #222)
3. Personal Income (Schema #333)
4. Proof of Address  and other KYC (Schema #444)
5. Net worth (Schema #555)
6. Credit worthiness (Schema #666)
7. Appraisal value of the property he wants to buy (Schema #777)
```

Based on the attestations above, Lenders can decide whether or not they want to loan to Bob to buy a particular property. 
- If he meets their demands, (i.e. Credit score, income, Loan-to-Value, etc) They can deposit the USDC into the DAPP and atomically receive a lien on the property.   
- As soon as the government attests to the validity of the sale, the DAPP can atomically pay the seller and receive the NFT title from them.   
- The NFT can remain inside the DAPP custody contract until the mortgage is fully paid off, at which point it can be transferred to the sole owner.  
- Mortgage payments will be made inside the DAPP contract.  
- If the owner defaults on his mortgage payments, the Smart contract will realease the NFT title to the lender/bank, who can now take ownership of the property and sell it on some cool Mortgage DeFi platform trading site.

It‚Äôs the future.






================================================
FILE: docs/idea--zone/use--case--examples/licensing.md
================================================
---
sidebar_position: 20
---

# Licensing
How attestations can be used for credible entities to issue and manage licenses such as a business license, medical license, and more.

## Problem
The current process of issuing and managing licenses, such as a business license, is often slow, cumbersome, and expensive. Traditional licensing systems typically require applicants to fill out lengthy paperwork, submit multiple documents, and wait weeks or months for a decision. The lack of transparency and inefficiency in the process can lead to frustration for applicants and increased costs for licensing authorities.

Moreover, it is difficult for third parties, such as employers or customers, to verify the authenticity of licenses, which can lead to fraud and abuse.

## Opportunity
Attestations can be used to streamline the licensing process and provide more transparency and trust for all parties involved. By using attestations, government entities can issue and manage licenses in a more efficient and secure manner.

For example, applicants can submit their license application through a decentralized application that leverages attestations. The application can use attestations to verify the applicant's identity, qualifications, and other relevant information, allowing the licensing authority to make a more informed decision in a shorter amount of time.

Once the license is issued, the applicant can maintain it as an attestation, and the licensing authority can use attestations to track renewal dates, revocations, and other important information. This provides a more transparent and auditable record of the licensing process.

To verify a license, the relevant parties could simply access the attestation and verify its authenticity. For example, a business owner applying for a permit could present their license attestation to the relevant authority, who could then verify its authenticity and other details using a simple interface.


## Example
Let's say a business owner wants to obtain a license to operate their business in a particular jurisdiction. They would fill out an application on a decentralized application that leverages attestations, providing their personal information, business details, and other relevant information. The application would then use attestations to verify the owner's identity, business registration, tax compliance, and other relevant criteria.

Once the licensing authority approves the application, the license would be issued as an attestation on the blockchain. The business owner would then maintain the license as an attestation, which would be used to track renewals and other important information.

### Sample Schema
This is an example schema that would include a few details about the business name, address, and tax ID. Further it would include a categorized list of license types and the date it was issued. Recall that each attestation always comes with a unique identifier (UID), revocation status, and expiration date if applicable.

```jsx
string businessName
string address
string taxId
uint8 licenseType
uint64 issuedDate
```

## Future Composability
Using attestations for licensing can be extended to other domains as well, such as medical licensing, professional licensing, and more. Attestations can also be used to verify the credentials of individuals and organizations, ensuring that they meet the necessary requirements for a particular license or certification. By creating a more transparent and efficient licensing process, attestations can help to drive innovation and growth in various industries.



================================================
FILE: docs/idea--zone/use--case--examples/oracles.md
================================================
---
sidebar_position: 13
---

# Oracles

## Problem
Decentralized applications (dapps) require accurate and timely real-world data to function correctly. However, fetching and verifying this data on-chain can be slow and expensive. Existing oracle services are often controlled by centralized teams, which can be a single point of failure and compromise the integrity of the data.

## Opportunity
Attestations can provide a decentralized and efficient way to obtain accurate real-world data for blockchain-based applications. By using a designated group of oracle providers, each attesting to the authenticity of the data they provide, these attestations can ensure accountability for data quality. 

## Example
An insurance dapp needs to verify that a specific event, such as a flight delay or cancellation, has occurred before paying out a claim. The dapp can use an off-chain oracle to obtain the necessary data.

The oracle service provider is designated to provide flight data for specific airlines. When a flight delay occurs, the airline notifies the oracle, which verifies the delay and attests to the authenticity of the data by providing an attestation.

The insurance dApp can then use the attestation to trigger a payout to the policyholder, who receives the funds in their wallet. This process provides an efficient way to verify the authenticity of real-world data without the need for the dApp to go through a time-consuming and costly verification process.

## Sample Schema

```jsx
uint32 flightNumber,
uint64 departureTime,
bytes32 airline,
bool isDelayed
```

## Future Composability
Oracle attestations can be combined with other types of attestations to create more complex workflows. For example, a supply chain dapp could use oracle attestations to verify the location of goods in transit, while also using attestations to verify the quality of the goods and their provenance. By combining multiple types of attestations, the dapp can create a more robust and secure system for tracking goods and ensuring their quality.




================================================
FILE: docs/idea--zone/use--case--examples/peer-to-peer-lending.md
================================================
---
sidebar_position: 6
---

# P2P Lending

## Problem
Current lending protocols in DeFi rely on over-collateralized loans, which limit access to credit for those who do not have sufficient collateral. This creates a barrier to entry for many people who could benefit from access to credit. Additionally, traditional credit scores are not applicable in DeFi, so it is difficult to establish trust between lenders and borrowers.

## Opportunity
Attestations offer a way to establish trust between lenders and borrowers in DeFi, paving the way for undercollateralized loans. By using attestations to establish creditworthiness and risk profiles, lenders can make informed lending decisions based on verifiable data.

This opens up new opportunities for peer-to-peer lending, enabling a wider range of people to access credit. It also has the potential to transform the traditional credit score system, by allowing individuals to build up a verifiable reputation over time through attestations.

## Example
Alice is looking for a loan to start her new business, but she does not have significant collateral to secure a loan. Bob, a lender, is interested in lending to Alice but needs to assess her risk profile. Bob can verify different attestations that matter to him, like Alice's employment history, payment record, and even a credit score attestation from a credit bureau. Alice can then be scored based on these factors and assigned a risk rating, allowing Bob to offer an undercollateralized loan with lower interest rates than traditional lending systems.

Bob can also use attestations to verify Alice's identity further assess her risk. Once the loan is issued, both Alice and Bob can track the loan payments on Ethereum, allowing for transparent and secure lending. As Alice makes on-time payments, her risk profile will improve, and she can access larger loans with better interest rates in the future. Each time a payment is made an additional attestation can be issued as a form of payment receipt. This payment receipt can then be used to form a composable and interoperable payment trail of her loans.

## Sample Schema
With this schema, a borrower can make an attestation for their loan request, which would include the relevant loan details such as the loan ID, principal, interest rate, and payment due date. Once the loan has been issued, the borrower would make another attestation for each payment made on the loan, referencing the loan ID and including the payment amount and date. Lenders can then use these attestations to verify the borrower's payment history and assess their creditworthiness for future loans.


```jsx
//The Loan
bytes32 loanID
address borrower
address lender
uint256 principal
uint256 interestRate
uint32 loanTerm
uint64 paymentDueDate
bytes32[] loanMetadata

//Loan Payment
bytes32 loanID
uint256 paymentAmount
uint64 paymentDate  
```

By using attestations for loan payments, lenders can have more confidence in lending to undercollateralized borrowers, as they can verify that the borrower has a history of making timely payments. This opens up new opportunities for peer-to-peer lending and undercollateralized loans in DeFi, as borrowers can now leverage their reputation to access credit without having to put up excessive collateral.

## Future Composability 
As more users adopt attestations for peer-to-peer lending, we can start to see the creation of a more robust reputation system for the DeFi space. This reputation system could be used in various DeFi applications to assess risk profiles, provide undercollateralized loans, and reduce collateral requirements. In addition, it could be used to track borrowers' payment histories and provide a novel credit score in the DeFi world. With attestations, we can help to create a more democratic and equitable lending system that promotes innovation and financial inclusion.




================================================
FILE: docs/idea--zone/use--case--examples/prediction-market.md
================================================
---
sidebar_position: 14
---

# Prediction Markets

## Problem
Prediction markets rely on accurate and timely information to function properly. However, many current prediction markets struggle with issues such as inaccurate data sources, low liquidity, and lack of transparency.

## Opportunity
Using attestations, prediction markets can provide a decentralized source of truth for real-world outcomes. Attestations can be used to verify the accuracy of data sources and ensure transparency in decentralized market operations.

## Example
A prediction market allows users to bet on the outcome of a future event, such as a political election or a sporting event. The market operates by allowing users to buy and sell shares in the possible outcomes, with the price of each share representing the probability of that outcome occurring.

To ensure the accuracy of the market, attestations can be used to verify the real-world outcome of the event. For example, if the prediction market is focused on a political election, an attestation can be made by a trusted third-party to confirm the actual outcome of the election.

This attestation provides a decentralized source of truth for the market, ensuring that the outcome is accurate and transparent. It also provides an opportunity for users to stake their tokens on the outcome, incentivizing accurate reporting and increasing liquidity in the market.

## Sample Schema
In this schema, the marketID identifies the specific prediction market, while the outcomeID corresponds to the outcome being predicted, such as which team won the game. The outcomeValue indicates the actual outcome and is used to attest to the result of the real-world event.

```jsx
bytes32 marketID
bytes32 outcomeID
uint256 outcomeValue
```

## Future Composability
With attestations, prediction markets can become more reliable and trustworthy. Participants can attest to the accuracy of the data used in the prediction market, providing a source of truth for the ecosystem. As the ecosystem grows, attestations can also be used to create new market incentives for individuals to participate and provide real-world data.

Moreover, oracle services can use attestations to obtain accurate data from multiple sources, creating a more decentralized and reliable system for prediction markets. By combining attestations with other types of attestations, such as off-chain oracles, prediction markets can be expanded to incorporate novel data sources and create new markets




================================================
FILE: docs/idea--zone/use--case--examples/proof-of-compliance.md
================================================
---
sidebar_position: 9
---

# Proof of Compliance

## Problem
In highly regulated industries, such as healthcare and finance, proving compliance can be a time-consuming and costly process. There is a need for a more transparent and efficient way to verify compliance without relying on extensive documentation and manual processes.

## Opportunity
With attestations as a form of proof of compliance, companies can create a secure and efficient way to verify compliance with regulatory and industry standards. Companies can create verifiable claims to demonstrate the steps taken to meet compliance requirements, establishing a transparent and auditable record of their compliance efforts. By using attestations, companies can reduce the complexity and costs of compliance audits and increase the efficiency and effectiveness of compliance management.

## Example
Let's take XYZ Corporation, a medical device manufacturer that must comply with FDA and industry regulations to ensure the safety and effectiveness of their products. To demonstrate compliance, XYZ creates off-chain attestations for each step of their process, including product testing, quality control, and documentation. These attestations are signed by responsible parties and kept as an immutable recorded in their private database.

During compliance audits, XYZ can provide the necessary private attestations, eliminating the need for time-consuming and costly manual reviews. The verifiable nature of these attestations builds trust with customers and regulators, improving the company's reputation and credibility in the market.

To prove their compliance with regulatory and industry standards, XYZ can use attestations without the need for extensive documentation. The immutable and transparent nature of these records ensures that compliance efforts are easily verifiable, while reducing the risk of fraud or errors.

For added privacy and security, the final proof of compliance can be an on-chain attestation from the auditors that only shows that compliance was achieved. This would help maintain data privacy while also providing easily verifiable proof of compliance on Ethereum.

## Sample Schema

```jsx
bytes32 regulationId
string standardName
bytes32 stepId
uint64 date
string description
address responsibleParty
```

## Future Composability 
Proof of compliance attestations can be extended to other industries and use cases, such as verifying compliance with environmental regulations, data privacy laws, and financial reporting standards. By creating a decentralized ledger of compliance attestations, we can establish a foundation of trust and transparency for compliance management across all industries.


================================================
FILE: docs/idea--zone/use--case--examples/proof-of-funds.md
================================================
---
sidebar_position: 9
---

# Proof of Funds

## Problem
In the world of finance, proving funding can be a time-consuming and invasive process. Financial institutions often require a significant amount of documentation to verify that an individual or entity has sufficient funds for a transaction. The process can be challenging for individuals and businesses, as it often requires sharing sensitive financial information that could be at risk of exposure.

## Opportunity
Proof of funds attestations can provide a secure and efficient way to verify the funding status of an individual or entity without requiring the disclosure of sensitive information. By using private data attestations with Merkle Trees, users can selectively disclose specific data fields, such as the current cash balance or credit score, while keeping other information private. This allows for a more tailored approach to information sharing, reducing the risk of fraud or errors and streamlining the verification process.

## Example
Alice wants to make a cash offer on a new home, but first, she must prove that she has sufficient Proof of Funds to pay for it.

Bob's Regional Bank creates a private data attestation for Alice's known wallet address, including details such as her current cash balance, whether she has over $100k, and her credit score.

Bob's Regional Bank attests to the private data, which generates a Merkle tree root hash of all the fields. The created attestation only contains the "Private Data" bytes32 value representing the Merkle tree root. This "Private Data" is accessible exclusively to the original attestor address or those who have received and verified any proof of the data. Once the attestation is made, Bob's Bank can provide Alice with the entire data from the tree which will allow her to generate proofs from it.

Alice generates a proof/leaf for the desired data field. In this case, Alice wants to share her legal name and confirm that her balance is over $100k. By clicking 'Generate Proof,' she obtains the 'Proof Result.'

The provided proof can be verified against the attested Merkle tree root hash, ensuring secure confirmation of the disclosed data without exposing the entire dataset.

With this approach, Alice can selectively disclose specific parts of her encoded data by generating a proof/leaf for the desired data field, while maintaining the overall privacy of her attested data.


## Sample Schema
This sample schema for "Proof of Funds" includes only two fields: `requestedAmount` and `hasSufficientFunds`.

- The `requestedAmount` field represents the amount of funds that are being requested for a particular transaction, such as purchasing a home.
- The `hasSufficientFunds` field is a boolean value that indicates whether the individual or entity has sufficient funds to cover the requested amount.

This approach reduces the amount of sensitive financial information that needs to be shared, as only the requested amount and whether it can be covered are needed, increasing the overall privacy and security of the transaction.

```jsx
uint256 requestedAmount
bool hasSufficientFunds
```

[Read a more detailed explaination of how this could work.](https://mirror.xyz/0xeee68aECeB4A9e9f328a46c39F50d83fA0239cDF/BiFUEFJKo6ZsIvPwsP9WPC2UZX0-x_9BdtrvmQo1FwY)

## Future Composability 
Proof of funds can be used in various transactions such as buying a car, home or even extending to Proof of Reserves for companies to verify they have sufficient assets to cover user funds.


================================================
FILE: docs/idea--zone/use--case--examples/proof-of-provenance.md
================================================
---
sidebar_position: 8
---

# Proof of Provenance

## Problem
Counterfeit goods are a significant problem in the global market. Consumers are often unaware of the true origin of the products they buy, leading to a loss of revenue for legitimate businesses and potential harm to consumers who may unknowingly purchase harmful or low-quality goods. Further, supply chains can be long and complex, making it difficult to track the origin of a product.

## Opportunity
Blockchain-based attestations can provide a solution to this problem by creating a transparent and immutable record of a product's provenance. By creating verifiable claims about the origin, authenticity, and ownership of a product, we can create a reputation system that builds trust between producers, distributors, retailers, and consumers. This will enable individuals and organizations to authenticate the parties they are dealing with and to restore trust in the origin of goods.

## Example
Alice is a farmer who produces organic vegetables. She wants to ensure that her customers can trust the origin of her products and that they are genuinely organic. To do this, Alice creates an attestation that references a hash of the batch number, along with the location and date of production.

Bob is a distributor who wants to ensure that the products he sells are genuinely organic and are sourced from reputable producers. To do this, Bob verifies the product batch is from Alice and makes an attestation that references Alice's attestation, attesting to the authenticity of the products.

Once the products are shipped to retailers, customers can also verify and make further attestations to the validity and authenticity of the products. This provides additional layers of verification and helps to establish trust in the origin of the products being provided.

This approach provides a simple and secure way to ensure the provenance of goods in the supply chain. By using attestations, producers, distributors, retailers, and consumers can create a reputation system that builds trust between each other.

## Sample Schema
This schema assumes that the attestor is the manufacturers address. The `productID` can be a unique identifier for a specific product that includes all necessary information such as product name, manufacturer, and other relevant details. As the product is sold and moved throughout the supply chain there can be an immutable chain of record showing where the product originated and where it ended up. This would be verifiable through the chain of attestations made throughout the supplychain process.


```jsx
bytes32 productID
bytes32 batchNumber
string locationOfProduction
uint64 dateOfProduction
```


## Future Composability 
With the use of attestations for proof of provenance, we can create a reputation system for product producers, distributors, retailers, and consumers, which can help to combat counterfeit goods, fraud, and forgery. This can be extended to other industries, such as art, luxury goods, and pharmaceuticals, where verifiable claims can be used to prove the origin, authenticity, and ownership of a product. By building a decentralized ledger of provenance, we can ensure that the integrity and authenticity of products are maintained, providing a foundation for trust in the global market.




================================================
FILE: docs/idea--zone/use--case--examples/reputation-systems.md
================================================
---
sidebar_position: 4
---

# Reputation Systems

## Problem
Reputation systems are an important part of many online platforms and communities, yet they are often limited by centralized and opaque rating systems. Traditional rating systems also make it easy for users to manipulate ratings or game the system. It can be difficult to establish trust in a community where reputation is not easily verifiable or there is no way to accurately measure it.


## Opportunity
Trust is relative, and individuals trust certain entities based on their own context and experiences. With attestations, we can create customizable reputation systems that reflect these varying levels of trust. Attestations allow individuals to determine what types of inputs and factors matter to them when calculating a trust score for an entity.

For example, a person might value attestations from their close friends or family members more highly than attestations from strangers. Alternatively, they might place more value on attestations from verified experts or reputable organizations.

By using attestations to build reputation systems, we can create more robust and verifiable systems that are less prone to fraud and manipulation. These systems can be used for a wide range of applications, such as verifiable reviews, social scores, smart contract reputations, and more. With the flexibility and customization of EAS, the possibilities are endless for creating decentralized reputation systems that accurately reflect an individual's trust and relative context.

Attestations can be used to verify various aspects of reputation, such as:
- Relevant trust scores 
- Skills and expertise
- Work experience and employment history
- Education and credentials
- Social reputation and interactions
- Smart contract reputation

With EAS, these attestations can be recorded on Ethereum or off-chain, providing a secure and tamper-proof record of reputation.

## Example
Alice is a freelancer who wants to establish a strong reputation online. She asks her clients to provide attestations about her work, which can include details about her punctuality, quality of work, and communication skills. Alice also obtains attestations from her school, which validate her skills and knowledge in her field.

The attestations from Alice's clients and school are stored on a blockchain and can be used to calculate Alice's reputation score. Because the attestations are made by trusted sources, they carry more weight and are less prone to fraud and manipulation than self-made endorsements.

Alice's reputation score can be used to help her find new clients, and potential clients can verify her reputation by looking at the attestations from her previous clients and school.


## Sample Schema
```jsx
string clientName
uint8 workQuality 
uint8 communicationSkills 
uint8 punctuality
uint8 valueOfWork 
bool recommend
```
- `clientName` (string): The name of the client who is providing the attestation.
- `workQuality` (uint8): A score between 1-100 indicating the quality of the freelancer's work.
- `communicationSkills` (uint8): A score between 1-100 indicating the freelancer's communication skills.
- `punctuality` (uint8): A score between 1-100 indicating the freelancer's punctuality.
- `valueOfWork` (uint8): A score between 1-100 indicating the value of the freelancer's work.
- `recommend` (bool): A boolean indicating whether or not the client would recommend the freelancer.

## Future Composability 
By using attestations and building trust scores, we can unlock many new use cases for digital trust online. Reputation systems can help to rethink and evolve traditional big brother systems like credit scores and background checks. With attestations, people can have a more transparent and verifiable reputation that is built on trust rather than relying on centralized authorities. This opens up new possibilities for social scoring, peer-to-peer lending, decentralized marketplaces, and more. By building a web of trust, we can create more honest and secure digital interactions that empower individuals and communities. This has the potential to be a truly revolutionary shift in the way we build digital trust.



================================================
FILE: docs/idea--zone/use--case--examples/roles-and-authorizations.md
================================================
---
sidebar_position: 3
---

# Roles & Authorizations

## Problem
Current centralized platforms like Discord and others pose significant challenges to achieving true decentralization for communities, particularly in terms of community management and authorizations. Membership tokens are often transferable, bad actors and spam can easily disrupt community progress, and reputation systems and voting systems are centralized in the platform.

## Opportunity
Decentralized communities can take ownership of their governance and generate more honest and transparent opportunities through the use of attestations. Using EAS, communities can create customizable schemas to define community roles and responsibilities. With attestation-based management, community members can be authorized to perform specific tasks based on their unique skills, experience, and reputation within the community. Attestations also promote transparency and accountability, enabling members to self-manage without the need for centralized authorities or systems, while reducing fraud and fostering trust.

## Example
When Alice joins the DAO as a solidity engineer, the organization creates an immutable but revocable attestation that allows her to access the community. This attestation contains information about Alice's assigned "roleID" and the "teams" she is a part of. If Alice's role or status changes, the DAO can revoke the attestation, effectively cutting off her access.

The great thing about this system is that Alice has a permanent record of being a member of the DAO, while the organization can still maintain control over who has access to its resources. Revoking access could be necessary if someone is behaving badly, not contributing enough, or if their role changes in the organization.

## Sample Schema
```jsx
bytes32 roleID
bytes32[] authorizations
bytes32 memberID
```

## Future Composability 
With attestations, DAOs can attest to other aspects of their members' engagements in the community. For example, a DAO could create an attestation for a member's level of participation, such as the number of proposals made, the number of votes cast, or the amount of work contributed. Members can then use these attestations to prove their participation and involvement in the community.

In addition, authorizations can be used for other permissions besides access to the community, such as voting, approvals, and decision-making. Attestations can also be used to create reputation systems that help members build trust and recognition within the community, leading to more opportunities and collaborations. As EAS is a customizable and versatile platform, the possibilities for future composability are endless.








================================================
FILE: docs/idea--zone/use--case--examples/social-graphs.md
================================================
---
sidebar_position: 18
---

# Social Graphs

## Problem
Social media networks today are highly fragmented and siloed, with each network building their own proprietary social graph that is incompatible with other networks. This leads to a lack of interoperability between networks, creating barriers for users and developers alike. As a result, users find it difficult to move between networks or use third-party applications that work across multiple networks.

Additionally, many decentralized social graphs in Web3 are built one layer too high, relying on centralized communities and data that is not interoperable outside of the social graph. This results in a further fragmentation of innovation, with developers having to create applications that are specific to each social graph, rather than creating solutions that work across different graphs.

Too often are social graphs constrained to social media type of applications. We can extend the value of the social graphs to be much more than that if they are truly interoperable with Web2 and Web3 ecosystems.

## Opportunity
Using EAS as the base layer for social graphs enables the creation of truly decentralized and interoperable social networks. Attestations provide a way for users to securely and selectively share their data with others, while retaining control over their personal information.

By using attestations, users can prove their identity, skills, achievements, and other aspects of their digital lives without revealing sensitive information. Off-chain attestations can be used for messaging, reactions, and other forms of user-generated content, while on-chain attestations can provide transparency and immutability for critical aspects of the social graph, such as user identity and activity.

Using EAS as a common platform for social graph development eliminates the fragmentation and siloing that is prevalent in Web2 social networks. Devs can build social apps and services that work across different networks, while users can move seamlessly between different social graphs with their data and attestations intact. 

A social graph built on attestations can enable a wide range of use cases, from secure and private messaging to reputation systems, decentralized job boards, and more. With EAS, it is possible to build a social network that truly puts users in control of their data and activity, empowering them to create and participate in a more open, transparent, and interconnected Web3 ecosystem.

## Example
Tweets can easily be added to a social graph network by using off-chain attestations. Recall that each attestation made with EAS has an attestor address, timestamp, revocation status, optional recipient, referenced attestations, attestation data, and authenticity of the signature.

All the schema would need for a decentralized social graph for "Twitter" would be a string for tweeting. Once the attestation (tweet) is made, then users could "retweet" it by simply referencing the attestation UID and republishing it. Any type of reaction comments like a 'like', would also just be a form of attestation. 

### Sample Schema
```jsx
string tweet
```

## Future Composability
One of the major benefits of creating a standardized platform for social graph development with attestations is that it enables future composability. Different attestations can be combined and used together to provide more powerful and contextualized social solutions.

As more entities make attestations and contribute to a social graph, the graph becomes more powerful and useful. Users can use their digital identity to authenticate themselves to different services and applications, while organizations can use the identity to make more informed decisions about their customers or employees.

Creating a standardized and decentralized platform for social graphs with attestations is a complex task, but the potential benefits are immense. By providing a common framework for creating and verifying attestations, we can enable a more trustworthy and interoperable social network, enabling a new generation of innovative and unique social applications.



================================================
FILE: docs/idea--zone/use--case--examples/ticketing-systems.md
================================================
---
sidebar_position: 12
---

# Verified Ticketing

## Problem
Ticket scalping, counterfeit tickets, and unauthorized access to events are common problems in the event industry. Traditional ticketing systems often require multiple intermediaries, which can result in additional costs, longer wait times, and increased potential for fraud.

## Opportunity
Off-chain attestations using EAS can provide a secure and efficient way to manage ticketing systems. By creating an attestation for each ticket, users can selectively disclose specific data fields, such as the ticket type, owner, and event information while keeping other information private. This allows for a more tailored approach to information sharing, reducing the risk of fraud or errors and streamlining the verification process.

## Example
Alice wants to attend a crypto conference and purchases a ticket from the event's website. The event organizers create an attestation for the ticket, including the ticket type, owner, and event information. The attestation is then made to Alice's Ethereum address, granting her permission to access the event.

Once Alice attends the event, the organizers can issue a proof of attendance attestation to her Ethereum address, confirming that she was present at the event. This proof of attendance can be used for future events, providing Alice with additional benefits, such as early-bird access or special discounts.

If Alice decides to sell her ticket, she can transfer ownership to the new owner by revoking the original ticket attestation and reissuing it to the new address, creating a chain of ownership and preventing the resale of counterfeit tickets.

## Sample Schema

```jsx
bytes32 eventID
bytes32 ticketID
```

## Future Composability
As the attestation ecosystem grows, ticketing systems can become even more robust and efficient. Proof of attendance can be extended to other events, such as concerts, sporting events, and festivals, providing attendees with additional benefits and rewards. Attendee attestations can also be combined with other attestations providing event organizers with additional information while maintaining user privacy. Overall, off-chain attestations with EAS have the potential to revolutionize the ticketing industry, making it more secure, efficient, and enjoyable for everyone involved.





================================================
FILE: docs/idea--zone/use--case--examples/transparent-funding.md
================================================
---
sidebar_position: 19
---

# Transparent Funding
How attestations can be used to create more transparency in funding public goods, grants, and hackathon competitions.

## Problem
The current systems for funding public goods, grants, and hackathons often lack transparency, making it difficult to independently verify decisions, votes, and the use of funds. This creates opportunities for fraud, corruption, and inefficiencies in the distribution of resources.

For example, in the case of public goods funding, there may be a lack of clarity around which projects are eligible for funding and how those decisions are made. In the case of grants, it can be challenging to ensure that the funds are being used for their intended purposes. In hackathon competitions, it may not be clear who can vote, how the voting process is conducted, or how the funds are allocated to the winning projects.

## Opportunity
Attestations provide a solution to these challenges by enabling more transparent and auditable funding mechanisms for public goods, grants, and hackathons. By using attestations, it is possible to create a verifiable record of project eligibility, voting, funding, and project compliance.

For example, project eligibility can be established through attestations of skills, experience, or reputation. Voting can be conducted using attestations of identity, reputation, or other criteria, with the results being recorded on Ethereum. Funding can be distributed using attestations of milestones achieved or services rendered. Compliance can be ensured through attestations of project progress or the use of funds, as well as through audits or inspections of attested records.

## Example
Let's say a grant program wants to use attestations to verify the eligibility and progress of its projects. The program could require each project to submit an attestation of their qualifications and experience, which would then be reviewed and attested by independent validators. Once the projects are approved, the program could use attestations to track their progress and ensure that the funds are being used for their intended purposes.

For instance, each project could submit attestations of their milestones achieved, with validators attesting to the completion of each milestone. The program could then distribute the funds based on these milestones, with attestations of funds received and milestones achieved serving as proof of progress and compliance. Audits could also be conducted using the attested records to ensure that the funds are being used appropriately.

### Sample Schema
```jsx
//Grant Proposal Request
string projectName
string description
address beneficiary
uint256 amountRequested
uint64 submittedTime
bytes32 proposalHash

//Grant Milestone
bytes32 projectId
bytes32 milestoneId
uint256 amount
bool isCompleted
```

## Future Composability
By using attestations to create more transparent and auditable funding mechanisms, it is possible to build a more accountable and efficient system for distributing public goods, grants, and hackathon funds. These attestations can also be used in combination with other Web3 technologies, such as decentralized identity systems and smart contracts, to create more sophisticated and automated funding mechanisms.

For example, attestations could be used to verify the identity and reputation of voters in quadratic voting systems for hackathons. They could also be used to enable decentralized decision-making in funding mechanisms, with attestations of stake or reputation determining the weight of each voter's decision. Overall, attestations provide a powerful tool for creating more transparent and equitable funding mechanisms in Web3.





================================================
FILE: docs/idea--zone/use--case--examples/vital-records.md
================================================
---
sidebar_position: 16
---
# Vital Records

## Problem
Obtaining a copy of a birth certificate can be a long and inefficient process. Often, individuals need to visit a vital records office in person, mail in an application, or wait weeks for the document to arrive by mail. This process can be frustrating and time-consuming, especially in urgent situations.

In addition, paper-based records can be prone to fraud and errors, leading to long-term risks and challenges for individuals and governments alike. Moreover, paper-based systems are not privacy-preserving, and sensitive information such as the mother's maiden name, home address, and social security number can be exposed.

## Opportunity
Attestations, together with privacy-preserving technologies like zk or merkle trees, can provide a secure and efficient solution for vital records, such as birth certificates. By recording birth certificates on Ethereum, individuals can easily access and share their official documents in a matter of minutes, rather than weeks, while keeping their sensitive information private.

Attestation-based vital records also reduce the risk of fraud and errors, as the immutability of blockchain ensures that records cannot be tampered with or altered.

## Example
A parent wants to enroll their child in a school, but the school requires a copy of the child's birth certificate. In the traditional paper-based system, the parent needs to visit the vital records office, present their ID, fill out an application, and wait weeks for the document to arrive by mail. This process is inefficient and cumbersome.

With attestations and privacy-preserving technologies, the parent can access their child's birth certificate in a matter of minutes, without revealing any sensitive information. The parent can simply provide the school with a digitally signed attestation from the government, which confirms the authenticity of the birth certificate and the identity of the child.

## Taking a Privacy First Approach
:::danger Developers must take a privacy-first approach
:::
EAS does not presuppose which privacy-preserving technology is best for any use case. However, the privacy of individuals must be a top priority. 

EAS also allows users to create [Private Data Attestations](/docs/tutorials/private-data-attestations). `Private Data Attestations` take advantage of Merkle Trees' unique capabilities to selectively disclose specific data fields without compromising overall privacy. This innovative feature allows users to create attestations with a single "private data" field, which contains the hash of a Merkle tree root. As a result, users can securely store and share particular parts of their attested data while preserving their privacy.

Attestations with `Zero Knowledge Proofs` are another path forward to explore. 

## Sample Schema
```jsx
bytes32 birthCertificateID
bytes32 firstName
bytes32 lastName
uint256 dateOfBirth
```

## Future Composability
The attestation-based birth certificate registry can be extended to include other types of vital records such as marriage certificates, death certificates, and divorce decrees. Additionally, the system can be integrated with other privacy-preserving systems, such as healthcare records or educational records, to provide a more comprehensive view of an individual's vital information while preserving their privacy. This composability enables governments to create a more secure, efficient, and privacy-preserving system of vital records management.


================================================
FILE: docs/idea--zone/use--case--examples/voting-systems.md
================================================
---
sidebar_position: 5
---

# Voting Systems

## Problem
Current voting systems often suffer from fraud, misrepresentation, and a lack of transparency. Tokenized voting systems, such as those used in many DAOs, can also suffer from voter apathy, where those with more tokens have more say, creating unequal and unfair outcomes. These issues make it difficult to trust the outcome of any vote, which undermines the entire concept of democracy.

## Opportunity
Attestations offer a secure and transparent way to implement digital voting systems. With attestations, voters can be verified as unique individuals, and their votes can be recorded in a way that is tamper-proof, immutable, and transparent.

Voting systems that use attestations can be flexible and customizable, allowing for different voting mechanisms like quadratic voting systems or one person one vote. It can be used for both online communities and national elections, allowing for fair and democratic voting that can be audited and verified by anyone.

## Example
Let's say a DAO needs to elect new leaders. Each member of the DAO has a specific membership attestation. To vote, members can make an attestation, or vote, for the candidate they want to elect. The voting process would be open and transparent, with each vote recorded on the blockchain. Once the voting period closes, the votes can be tallied based on the attestations made. The quadratic voting system would ensure each member has an equal say in the outcome, and the use of attestations would ensure the integrity and transparency of the election.


## Sample Schema
This is an example schema. The attestor (DAO member) would make an attestation to the candidate address, which would simply be the recipient of the attestation. Then the DAO member would cast the # of votes they want to allocate to that candidate and their role.

To make the process even more efficient and scalable, we can use tuples to map the candidate ID and the number of votes they received. This will allow for easy vote counting and tallying. The schema would look like this:

```jsx
uint64 votes
bytes32 roleID
```

We would like to give a special shoutout to the Devfolio (ETHIndia) team who implemented a quadratic voting system for their recent hackathon. They used an attestation-based voting system with quadratic voting to have a more transparent and verifiable voting process. We believe that this is just the beginning of the potential for attestations to transform voting systems and enable more democratic decision-making.

[Learn more about Devfolio's Quadratic Voting System using Attestations](https://devfolio.co/blog/introooducing-quadratic-voting-on-devfolio/)

## Future Composability 
Attestations have the potential to unlock many new use cases for digital trust online. By enabling more secure and transparent voting systems, we can rethink and evolve traditional voting systems to be more fair and democratic. As digital identities become more robust through the use of attestations, voting systems will become easier to implement, and the potential for future composability will be limitless. This will allow for more advanced reputation systems, improved decision-making processes, and the ability to unlock new use cases beyond what is currently possible.


================================================
FILE: docs/purpose/_category_.json
================================================
{
  "label": "Purpose",
  "position": 2,
  "link": {
    "type": "generated-index"
  }
}



================================================
FILE: docs/purpose/attestation-ecosystem.md
================================================
---
sidebar_position: 3
---

# Attestation Ecosystem
:::info What makes an ecosystem thrive?
:::
Picture a vibrant city, alive with energy, where every street, bridge, and alleyway pulses with activity. What's the secret to its rhythm? It's the infrastructure that invisibly weaves and binds everything together, allowing everyone in it to thrive.

In the attestation ecosystem, we've long felt **the absence of such a foundational infrastructure**. Efforts to establish trust, verify identities, and ensure authenticity have often been siloed, leading to a fragmented landscape. Many have tried to build solutions, but they've often started at the top or **building one layer too high**. This approach, while well-intentioned, has only added to the fragmentation, creating a patchwork of for-profit solutions that don't always speak the same language.

Worse still, past infrastructure **attempts have been encumbered by centralization, permissioned systems, and biases that presuppose too much**. Such systems, while offering a semblance of structure, are inherently flawed. They limit growth, deter widespread adoption, and, most critically, place too much power in the hands of a few at the expense of others.

## Growth Pyramid
EAS is designed to be that foundational infrastructure for the attestation ecosystem. Neutral, open, and built for the community, without presupposing too much or building too high in the stack.

![Attestation Ecosystem Pyramid](./img/attestation-pyramid-v1.png)

## The Attestation Growth Loop
At the heart of the Attestation Ecosystem is the Ethereum Attestation Service (EAS). It's the foundational infrastructure that sets a powerful growth cycle into motion:

- **Infrastructure:** EAS provides a robust and neutral infrastructure. This foundational layer ensures that every attestation, regardless of its origin or purpose, speaks the same technical language.
- **Coordination:** With a standardized infrastructure in place, stakeholders come together to coordinate around schemas and improvements to the infrastructure. They discuss, deliberate, and decide on the best practices, ensuring that the ecosystem evolves cohesively.
- **Structured Attestations:** Guided by the coordinated efforts, entities make clear and standardized attestations. These attestations are free from biases and are made without presupposing the structure at the infrastructure layer.
- **Insightful Analysis:** The structured attestations are then analyzed, leading to the extraction of valuable insights. These insights paint a comprehensive picture of trust and knowledge within the ecosystem.
- **Application Development:** Armed with these insights, developers create applications centered on trust. These applications cater to a wider audience, enhancing user experiences and solving real-world problems and add back to the insights.
- **Feedback and Growth:** The interactions within these applications generate more data, leading to richer insights and more attestations. This feedback loop requires continuous coordination, leading to improvements in the infrastructure. The cycle continues, driving growth in the ecosystem and reinforcing online trust.

EAS is the bedrock upon which the Attestation Ecosystem thrives. It ensures that the ecosystem remains open, decentralized, and ever-evolving, all while fostering a cycle of trust, collaboration, and progress.



================================================
FILE: docs/purpose/eas-purpose.md
================================================
---
sidebar_position: 1
---

# Why We Exist

EAS is an infrastructure public good for making attestations onchain or offchain about anything. It's the base layer for attesting. Seems abstract right? That's because it is. It might not be obvious why this is valuable, so it's helpful to learn why EAS was built.

## It's helpful to know the origin.
### We all expect more from decentralization.
When Ethereum first came out, there were all these grand visions to build a decentralized future for everything. Digital identities, reputation, land registries, supply chain provenance, voting, schools, and so much more. We wanted to decentralize it all. Yet, nearly a decade in, we've done amazing in financial sectors like Defi, but we've stumbled elsewhere. Especially in the quest to unravel digital identity. 

### The ecosystem is fragmented.
Imagine you have thousands of puzzle pieces scattered across the table. Each piece holds a tiny portion of the larger image. This is the current state of digital identity: fragmented, scattered, and often confusing. With so many protocols and platforms, each holding a bit of our identity, it's hard to see the complete picture. We need to bring these pieces together in a universal way.

The quest for digital identity has been relentless and challenging. This ignited a fundamental question in us: What, at its core, is identity?

### Rethinking identity.
Identity isn't about documents, cards, or credentials. It's a story. To break this complex topic down we asked... What was your first identity? At one point in your life you didn't have an identity and then you did. So what happened? 

We realized that when you're born, your mother named you. You can say, she attested to your name. From then on, life became a series of attestations‚Äî the doctor attested to your date of birth, the government attests to your passport, you go to school and the teacher attests to your grades, you attest to the friends that you like and the pizza you love most, you graduate and the university attests to your degree, your employer attests to your employment, and the list goes on. At every step of our lives, from our birth to our careers, there are attestations: statements made about us and that we make about others that shape our identity. It's these small threads, these attestations, that weave the fabric of our identity. 

### Building the Base Layer
What we need is a foundational layer for these attestations and puzzle pieces to come together. A protocol that allows for verifying anything and everything. And from this aggregation of attestations, we can naturally and elegantly derive our digital identity and much more. 

### We need to be able to attest about anything.
Digital identities as a collection of attestations ‚Äî it almost seems so obvious. But it doesn't end at people. Every interaction, every transaction, every trust placed is underpinned by an attestation, many yet to be digitized. Anytime an entity needs to attest or assert the truth about something, attestations will play a role. Think: Compliance, Proof of X, Verifications, Voting, Reviews, Knowledge Graphs, Oracles, Provenance, Ownership, Prediction Markets, Authenticity of Content, and more. 

### Give people choice.
Let's face it, everyone has a preference. Trust varies; it's deeply personal and nuanced. A casual assurance from a friend might be all some need, while others seek endless evidence. True trustworthiness, then, needs to be adaptable, transparent, and inclusive. As we strive for a decentralized world, the bedrock of our efforts should be a solid foundation of trust. Ethereum, with its inherent qualities of decentralization, immutability, authenticity, and verifiable timestamps, emerges as this very foundation. But to truly empower individuals and entities with choice, we need a unified method for attestations‚Äîone that helps bring clarity and options to the table.

Consider a simple loan example. An IOU scribbled on a napkin between friends could hold as much weight as a bank's meticulous documentation. Both avenues lead to the same end‚Äîa loan‚Äîbut the journey there is molded by the level of trust between the parties. This accentuates the crucial need for a dependable layer of trust.

## Where we're heading.

### A more trustful online & onchain world.
In our new world, identity is no longer a jigsaw puzzle scattered across platforms. It is an organized, verified, and respected aggregate of attestations. EAS brings us a future where identity and verification move beyond just people. Everything, from art and content to events and products, has a clear, verifiable story. EAS ensures that every piece of information, every attestation, finds its rightful place in the digital realm. It's about shaping a future that is transparent, trusted, and truly interconnected.


### Why this matters to devs.
Developers are the architects of our digital world. But constructing in a fragmented landscape is challenging. EAS offers devs a unified protocol, simplifying the complexities around structured and verifiable data. Instead of navigating through an endless list of solutions, developers now have a reliable, credibly neutral, and flexible infrastructure, making integration and scalability simpler. With EAS, they have the tools to create a more interconnected, trustworthy, and efficient digital space.

### Why this matters to product & non-technical builders.
For those shaping products and solutions, understanding attestations is crucial. EAS offers an intuitive way to harness the power of attestations. EAS provides a consistent foundation to build upon, ensuring that products are not just user-friendly but also robust in managing and verifying digital identities. It paves the way for innovative solutions that were previously unimaginable, making the digital experience richer and more authentic for users.



================================================
FILE: docs/purpose/public-good.md
================================================
---
sidebar_position: 2
---

# A Public Good Protocol
Public goods are foundational in driving innovation, collaboration, and trust within ecosystems like Ethereum. EAS, with its decentralized, open-source, and tokenless design for attestations, embodies this principle, offering a universally beneficial service.

![Eth Public Good](./img/Ethereum-center-of-trust.png)

## EAS is a Public Good
EAS stands out due to its commitment to being a public good. Its open-source, permissionless, and tokenless nature ensures that it remains neutral, fostering trust and integrity in the attestation ecosystem.

For a foundational layer addressing the very nuanced and personal facets of trust online, financial motivations or centralized control are counterproductive. While for-profit solutions excel in niche areas, they can't serve as primitive infrastructure due to inherent biases. Public goods focus on value creation over value extraction. 

EAS, as a public good, offers the base layer that's credibly neutral. While numerous businesses can thrive atop EAS, its primary role is to catalyze innovation, ensuring equitable opportunities for all.

## Mental Model: Email as a Public Good
When you send an email today, do you think about if the recipient uses gmail, outlook, or even AOL? No. You click send and the protocol communicates the email to the intended recipient. Application developers can create spam filters and other efforts to improve the user experience, but the role of email is to structure the information. Email is permissionless. It doesn't force anyone to register the types of emails you want to send people before being able to do so. This is an example of a public good protocol. Now let's imagine if email wasn't a public good and we had to send $X every time we "emailed". The industry would fragment. We'd have "f-mail", "d-mail", and other protocols competing on price and structure. Now anyone creating Microsoft Outlook, Gmail, or other applications on top of "email" would have to integrate other standards. 

EAS aims to be the universal language in how entities "attest" about anything. It's how the attestation data is structured and communicated. It's role is not to determine if the attestation is valuable (just like email doesn't judge how good or bad an email's content is), it's role is to coordinate how attestations are made in an elegant and efficient way.


## Understanding Public Goods
Public goods are universally accessible resources. They're available to all, and one's usage doesn't diminish their availability for others. Imagine a public park: open for all, irrespective of individual contributions to its upkeep.

Within Ethereum and the broader blockchain ecosystem, public goods span open-source codes, educational platforms, community gatherings, and projects emphasizing ecosystem enhancement over mere profit.

:::info Know the difference
Teams may claim to be a public good, but they are often for-profit and value extractive for their own gain.
::::

### Why Public Goods Matter
- **Trust Building:** Public goods are pillars of trust. For example, open-source codes champion transparency and collective refinement.
- **Foster Innovation:** Unrestricted access to tools and knowledge empowers developers and entities to evolve existing projects and create completely novel solutions.
- **Boost Collaboration:** Common platforms and resources amplify collaboration, offering a unified platform for collective success.
- **Impact over Profit:** Prioritizing impact over profit, public goods ensure unbiased, genuine contributions to and from the community.

### How Public Goods Grow
Building public goods demands dedication and time. Teams with a vision for impact often face the dilemma of securing funds without compromising their mission. However, our ecosystem is adept at starting and motivating impact-focused teams. Here are a few ways public goods, like EAS, grow:

#### Community Contributions
Public goods are built by small teams that often grow into large communities with a shared purpose to make the broader ecosystem, simply, better. Because of their often open-source and impact focused nature, many public goods benefit from the network effects and collective intelligence of the community looking to further its purpose.

Any small contribution whether it's calling out something to update on a docs page, writing an article or tweet educating about the public good, or directly contributing to the code base are all great ways to "contribute".

#### Grants & Donations
Many teams start public goods by bootstrapping funds and their time or by receiving donations, while noble, these funding sources are often not sustainable long-term. One step up are grants tailored for public goods. Grant programs are plentiful in the Ethereum Ecosystem with projects like:
- Funding Platforms ([Gitcoin](https://grants.gitcoin.co/), [Giveth](https://giveth.io/), [The Giving Block](https://thegivingblock.com/), [Endaoment](https://endaoment.org/) et.al)
- Ecosystem Grants ([Ethereum Foundation](https://ethereum.org/en/foundation/), [OP](https://community.optimism.io/docs/governance/get-a-grant/), [Arbitrum](https://arbitrum.foundation/grants?address=0xeee68aECeB4A9e9f328a46c39F50d83fA0239cDF), et.al).

#### Retroactive Funding
Ecosystems like Optimism have been championing [Retroactive Public Goods Funding](https://app.optimism.io/retropgf). The core idea behind retroactive funding is that it's easier to determine the impact of an innovation after it's made its impact. Thus, many teams like Optimism will fund Public Goods for the impact they make on their own ecosystem. As the impact is made, their ecosystem hits new growth goals or revenue targets and then allocates that benefit back to the team or innovation that helped them get there. Then these teams continue building into a virtuous cycle of innovation and growth.

#### Revenue Sharing
New models, like the [Public Goods Network (PGN)](https://publicgoods.network/), let public goods share in the revenue they help generate. If a public good boosts transaction volume on the network, it gets a piece of the fees generated.

## Conclusion
Public goods, like EAS, are the backbone of thriving ecosystems. They ensure that the foundation remains neutral, transparent, and accessible to all, fostering an environment where innovation and collaboration can flourish. Prioritizing the collective good over individual profit, public goods set the stage for a more inclusive and equitable future.

## Get Involved
EAS thrives on community involvement. Whether you're a developer, writer, or just an enthusiast, there's a place for you:

- **Contribute to the Codebase:** Dive into our [GitHub repository](https://github.com/ethereum-attestation-service) and help improve EAS.
- **Share Knowledge:** Write articles, create tutorials, or host webinars to spread the word about EAS.
- **Donate or Fund:** Support the project directly or guide us towards potential grants.
- **Join the Conversation:** Engage with us on [Builder's Telegram](https://t.me/+EcynOr0iFu03MTYx) or [Twitter](https://x.com/eas_eth) and be part of the EAS journey.

Remember, every contribution, no matter how small, pushes the mission forward. Let's build a more trustworthy and collaborative Ethereum ecosystem together!


================================================
FILE: docs/purpose/the-vision.md
================================================
---
sidebar_position: 4
---

# The Vision
Attestations can be used for so much. This is both a benefit and a challenge. If we're successful, where will they take us?

## A Trustful Tomorrow

What does it feel like to trust today? Imagine you're at your favorite city market. You recognize a few faces, shake hands with local vendors, and exchange stories with neighbors. There's a sense of community, a shared trust. You know who grows the best tomatoes, who bakes the freshest bread. It's all based on experience, recommendations, and genuine interactions relative to you. That's our real-world trust.

Now, think about our online world. It's like stepping into a massive global market. Faces are hidden behind screens, and every interaction feels like a gamble. Can you trust that online review? Is that seller genuine? Today, it's like navigating a maze without a map. That's our digital trust challenge.

But what if our online world felt more like that local market? Where you could recognize and trust digital "faces", not because of a platform's algorithm, but because of genuine, verifiable interactions that you care about. That's the power of attestations.

With attestations, we're not just adding a digital signature. We're giving every individual and business the tools to decide who they trust, what they trust, how they trust, and why. It's about creating a sense of "relative trust" online and giving users the choice. Just like you trust your neighbor's recommendation for the best bakery, in the digital space, you could trust a content creator because of genuine interactions and verified claims. This world doesn't have a universal trust score. Those make no sense. 

And here's where Ethereum and EAS come into play. They're not just building a digital infrastructure; they're crafting the very pathways of this new trust. It's like laying down roads in our digital market, making it easier for everyone to find their way, to recognize genuine merchants from the fleeting ones.

But, like every market, it's the community that truly defines it. And that's where you come in. To build this vision, to make our digital interactions as genuine as our real-world ones, we need you. Whether you're a developer, a content creator, or just someone who believes in a trustworthy digital future, your voice, your trust, your interaction matter.

So, let's come together. Let's make our online world a place where trust is built on genuine interactions, where every individual has the power to decide their trust. Let's make our digital market as familiar, as trustworthy, as our local one.

Together, let's shape a future where trust is, once again, at the heart of every interaction.

## The First Steps Towards Our Vision
Our journey starts now. But how do we transition from what is to what could be?

### Immediate Challenges:
- **Fragmented Trust:** Today, trust is scattered across platforms, each with its own standards and algorithms. This fragmentation makes it hard to have a consistent trust experience.
- **Over-reliance on Centralized Systems:** Centralized platforms hold a lot of power over our data and interactions. They decide who and what to trust, often based on profit motives rather than genuine interactions.

### The EAS Standard:
- **Unified Trust Framework:** EAS provides a standardized way to create and verify attestations, making trust more consistent across platforms.
- **Empowering Individuals & Builders:** With EAS, every individual gets to decide their trust parameters. You're not just a passive consumer; you're an active participant in shaping your digital trust landscape.

### Opportunities Ahead:
- **For Impact-Driven Individuals:** Dive into the world of attestations. Understand them, advocate for them, and help shape a future where trust is democratized.
- **For Profit-Driven Entities:** Recognize the potential of a trust-driven ecosystem. Build solutions that leverage the power of attestations, offering genuine value to users and reaping the rewards of a trust-centric business model.

## Let's get started
The future is in our hands. It's up to us to shape it. Start by understanding the power of attestations. Integrate them into your platforms, advocate for their adoption, and be a part of the community that's redefining digital trust.

Join us in this journey. Let's make the digital world as trustworthy as our favorite local market.



================================================
FILE: docs/quick--start/_category_.json
================================================
{
  "label": "Quick Start",
  "position": 3,
  "link": {
    "type": "generated-index",
    "description": "The fastest way to speedrun your education on EAS."
  }
}



================================================
FILE: docs/quick--start/contracts.md
================================================
---
sidebar_position: 2
---

# EAS Contracts

Please note that you can also import and use the addresses directly in your code using the @ethereum-attestation-service/eas-contracts/deployments deployment artifacts corresponding to your desired network.

## Deployments

Please note that you can also import and use the addresses directly in your code using the `@ethereum-attestation-service/eas-contracts/deployments` deployment artifacts corresponding to your desired network.

### Mainnets

#### Ethereum

Version 0.26:

- **EAS**:
  - Contract: [0xA1207F3BBa224E2c9c3c6D5aF63D0eb1582Ce587](https://etherscan.io/address/0xA1207F3BBa224E2c9c3c6D5aF63D0eb1582Ce587)
  - Deployment and ABI: [EAS.json](./deployments/mainnet/EAS.json)
- **SchemaRegistry**:
  - Contract: [0xA7b39296258348C78294F95B872b282326A97BDF](https://etherscan.io/address/0xA7b39296258348C78294F95B872b282326A97BDF)
  - Deployment and ABI: [SchemaRegistry.json](./deployments/mainnet/SchemaRegistry.json)

#### Optimism

Version 1.0.1:

- **EAS**:
  - Contract: [0x4200000000000000000000000000000000000021](https://optimistic.etherscan.io/address/0x4200000000000000000000000000000000000021)
  - Deployment and ABI: [EAS.json](./deployments/optimism/EAS.json)
- **SchemaRegistry**:
  - Contract: [0x4200000000000000000000000000000000000020](https://optimistic.etherscan.io/address/0x4200000000000000000000000000000000000020)
  - Deployment and ABI: [SchemaRegistry.json](./deployments/optimism/SchemaRegistry.json)

Version 1.2.0:

- **EIP712Proxy**:
  - Contract: [0xE132c2E90274B44FfD8090b58399D04ddc060AE1](https://optimistic.etherscan.io/address/0xE132c2E90274B44FfD8090b58399D04ddc060AE1)
  - Deployment and ABI: [EIP712Proxy.json](./deployments/optimism/EIP712Proxy.json)
- **Indexer**:
  - Contract: [0x6dd0CB3C3711c8B5d03b3790e5339Bbc2Bbcf934](https://optimistic.etherscan.io/address/0x6dd0CB3C3711c8B5d03b3790e5339Bbc2Bbcf934)
  - Deployment and ABI: [Indexer.json](./deployments/optimism/Indexer.json)

#### Base

Version 1.0.1:

- **EAS**:
  - Contract: [0x4200000000000000000000000000000000000021](https://basescan.org/address/0x4200000000000000000000000000000000000021)
  - Deployment and ABI: [EAS.json](./deployments/base/EAS.json)
- **SchemaRegistry**:
  - Contract: [0x4200000000000000000000000000000000000020](https://basescan.org/address/0x4200000000000000000000000000000000000020)
  - Deployment and ABI: [SchemaRegistry.json](./deployments/base/SchemaRegistry.json)

Version 1.2.0:

- **EIP712Proxy**:
  - Contract: [0xF095fE4b23958b08D38e52d5d5674bBF0C03cbF6](https://basescan.org/address/0xF095fE4b23958b08D38e52d5d5674bBF0C03cbF6)
  - Deployment and ABI: [EIP712Proxy.json](./deployments/base/EIP712Proxy.json)
- **Indexer**:
  - Contract: [0x37AC6006646f2e687B7fB379F549Dc7634dF5b84](https://basescan.org/address/0x37AC6006646f2e687B7fB379F549Dc7634dF5b84)
  - Deployment and ABI: [Indexer.json](./deployments/base/Indexer.json)

#### Arbitrum One

Version 0.26:

- **EAS**:
  - Contract: [0xbD75f629A22Dc1ceD33dDA0b68c546A1c035c458](https://arbiscan.io/address/0xbD75f629A22Dc1ceD33dDA0b68c546A1c035c458)
  - Deployment and ABI: [EAS.json](./deployments/arbitrum-one/EAS.json)
- **SchemaRegistry**:
  - Contract: [0xA310da9c5B885E7fb3fbA9D66E9Ba6Df512b78eB](https://arbiscan.io/address/0xA310da9c5B885E7fb3fbA9D66E9Ba6Df512b78eB)
  - Deployment and ABI: [SchemaRegistry.json](./deployments/arbitrum-one/SchemaRegistry.json)

#### Arbitrum Nova

Version 1.3.0:

- **EAS**:
  - Contract: [0x6d3dC0Fe5351087E3Af3bDe8eB3F7350ed894fc3](https://nova.arbiscan.io/address/0x6d3dC0Fe5351087E3Af3bDe8eB3F7350ed894fc3)
  - Deployment and ABI: [EAS.json](./deployments/arbitrum-nova/EAS.json)
- **SchemaRegistry**:
  - Contract: [0x49563d0DA8DF38ef2eBF9C1167270334D72cE0AE](https://nova.arbiscan.io/address/0x49563d0DA8DF38ef2eBF9C1167270334D72cE0AE)
  - Deployment and ABI: [SchemaRegistry.json](./deployments/arbitrum-nova/SchemaRegistry.json)
- **EIP712Proxy**:
  - Contract: [0xEbf2DeeD690F8A68b8248d6a12231ee70ED2154A](https://nova.arbiscan.io/address/0xEbf2DeeD690F8A68b8248d6a12231ee70ED2154A)
  - Deployment and ABI: [EIP712Proxy.json](./deployments/arbitrum-nova/EIP712Proxy.json)
- **Indexer**:
  - Contract: [0x7182Be5e84aFEe9Dc29C69D081F8A0FA834d6CB8](https://nova.arbiscan.io/address/0x7182Be5e84aFEe9Dc29C69D081F8A0FA834d6CB8)
  - Deployment and ABI: [Indexer.json](./deployments/arbitrum-nova/Indexer.json)

#### Polygon

Version 1.3.0:

- **EAS**:
  - Contract: [0x5E634ef5355f45A855d02D66eCD687b1502AF790](https://polygonscan.com/address/0x5E634ef5355f45A855d02D66eCD687b1502AF790)
  - Deployment and ABI: [EAS.json](./deployments/polygon/EAS.json)
- **SchemaRegistry**:
  - Contract: [0x7876EEF51A891E737AF8ba5A5E0f0Fd29073D5a7](https://polygonscan.com/address/0x7876EEF51A891E737AF8ba5A5E0f0Fd29073D5a7)
  - Deployment and ABI: [SchemaRegistry.json](./deployments/polygon/SchemaRegistry.json)
- **EIP712Proxy**:
  - Contract: [0x4be71865917C7907ccA531270181D9B7dD4f2733](https://polygonscan.com/address/0x4be71865917C7907ccA531270181D9B7dD4f2733)
  - Deployment and ABI: [EIP712Proxy.json](./deployments/polygon/EIP712Proxy.json)
- **Indexer**:
  - Contract: [0x12d0f50Eb2d67b14293bdDA2C248358f3dfE5308](https://polygonscan.com/address/0x12d0f50Eb2d67b14293bdDA2C248358f3dfE5308)
  - Deployment and ABI: [Indexer.json](./deployments/polygon/Indexer.json)

#### Scroll

Version 1.3.0:

- **EAS**:
  - Contract: [0xC47300428b6AD2c7D03BB76D05A176058b47E6B0](https://scrollscan.com/address/0xC47300428b6AD2c7D03BB76D05A176058b47E6B0)
  - Deployment and ABI: [EAS.json](./deployments/scroll/EAS.json)
- **SchemaRegistry**:
  - Contract: [0xD2CDF46556543316e7D34e8eDc4624e2bB95e3B6](https://scrollscan.com/address/0xD2CDF46556543316e7D34e8eDc4624e2bB95e3B6)
  - Deployment and ABI: [SchemaRegistry.json](./deployments/scroll/SchemaRegistry.json)
- **EIP712Proxy**:
  - Contract: [0x77b7DA1c40762Cd8AFfE2069b575328EfD4D9801](https://scrollscan.com/address/0x77b7DA1c40762Cd8AFfE2069b575328EfD4D9801)
  - Deployment and ABI: [EIP712Proxy.json](./deployments/scroll/EIP712Proxy.json)
- **Indexer**:
  - Contract: [0x8314bc1B2f7F286cb4f0323FE7119C0F99D4A083](https://scrollscan.com/address/0x8314bc1B2f7F286cb4f0323FE7119C0F99D4A083)
  - Deployment and ABI: [Indexer.json](./deployments/scroll/Indexer.json)

#### zkSync

Version 1.3.0:

- **EAS**:
  - Contract: [0x21d8d4eE83b80bc0Cc0f2B7df3117Cf212d02901](https://explorer.zksync.io/address/0x21d8d4eE83b80bc0Cc0f2B7df3117Cf212d02901)
  - Deployment and ABI: [EAS.json](./deployments/zksync/EAS.json)
- **SchemaRegistry**:
  - Contract: [0xB8566376dFe68B76FA985D5448cc2FbD578412a2](https://explorer.zksync.io/address/0xB8566376dFe68B76FA985D5448cc2FbD578412a2)
  - Deployment and ABI: [SchemaRegistry.json](./deployments/zksync/SchemaRegistry.json)
- **EIP712Proxy**:
  - Contract: [0x8E8F79e9A1Cd4da7bD2f15e5B0a4B4a613E37C5a](https://explorer.zksync.io/address/0x8E8F79e9A1Cd4da7bD2f15e5B0a4B4a613E37C5a)
  - Deployment and ABI: [EIP712Proxy.json](./deployments/zksync/EIP712Proxy.json)
- **Indexer**:
  - Contract: [0x8AdA7852df64A66ca89EFc82144e6be71Bd53B4E](https://explorer.zksync.io/address/0x8AdA7852df64A66ca89EFc82144e6be71Bd53B4E)
  - Deployment and ABI: [Indexer.json](./deployments/zksync/Indexer.json)

#### Celo

Version 1.3.0:

- **EAS**:
  - Contract: [0x72E1d8ccf5299fb36fEfD8CC4394B8ef7e98Af92](https://celoscan.io/address/0x72E1d8ccf5299fb36fEfD8CC4394B8ef7e98Af92)
  - Deployment and ABI: [EAS.json](./deployments/celo/EAS.json)
- **SchemaRegistry**:
  - Contract: [0x5ece93bE4BDCF293Ed61FA78698B594F2135AF34](https://celoscan.io/address/0x5ece93bE4BDCF293Ed61FA78698B594F2135AF34)
  - Deployment and ABI: [SchemaRegistry.json](./deployments/celo/SchemaRegistry.json)
- **EIP712Proxy**:
  - Contract: [0x6792B6AE17c6416016b943585e957a29bc452806](https://celoscan.io/address/0x6792B6AE17c6416016b943585e957a29bc452806)
  - Deployment and ABI: [EIP712Proxy.json](./deployments/celo/EIP712Proxy.json)
- **Indexer**:
  - Contract: [0x76591b332d0F099E89FA335fC827D44C47705D2f](https://celoscan.io/address/0x76591b332d0F099E89FA335fC827D44C47705D2f)
  - Deployment and ABI: [Indexer.json](./deployments/celo/Indexer.json)

#### Blast

Version 1.3.0:

- **EAS**:
  - Contract: [0x4200000000000000000000000000000000000021](https://blastscan.io/address/0x4200000000000000000000000000000000000021)
  - Deployment and ABI: [EAS.json](./deployments/blast/EAS.json)
- **SchemaRegistry**:
  - Contract: [0x4200000000000000000000000000000000000020](https://blastscan.io/address/0x4200000000000000000000000000000000000020)
  - Deployment and ABI: [SchemaRegistry.json](./deployments/blast/SchemaRegistry.json)

#### Linea

Version 1.2.0:

- **EAS**:
  - Contract: [0xaEF4103A04090071165F78D45D83A0C0782c2B2a](https://lineascan.build/address/0xaEF4103A04090071165F78D45D83A0C0782c2B2a)
  - Deployment and ABI: [EAS.json](./deployments/linea/EAS.json)
- **SchemaRegistry**:
  - Contract: [0x55D26f9ae0203EF95494AE4C170eD35f4Cf77797](https://lineascan.build/address/0x55D26f9ae0203EF95494AE4C170eD35f4Cf77797)
  - Deployment and ABI: [SchemaRegistry.json](./deployments/linea/SchemaRegistry.json)

### Testnets

#### Sepolia

Version 0.26:

- **EAS**:
  - Contract: [0xC2679fBD37d54388Ce493F1DB75320D236e1815e](https://sepolia.etherscan.io/address/0xC2679fBD37d54388Ce493F1DB75320D236e1815e)
  - Deployment and ABI: [EAS.json](./deployments/sepolia/EAS.json)
- **SchemaRegistry**:
  - Contract: [0x0a7E2Ff54e76B8E6659aedc9103FB21c038050D0](https://sepolia.etherscan.io/address/0x0a7E2Ff54e76B8E6659aedc9103FB21c038050D0)
  - Deployment and ABI: [SchemaRegistry.json](./deployments/sepolia/SchemaRegistry.json)

Version 1.2.0:

- **EIP712Proxy**:
  - Contract: [0x9C9d17bEE150E4eCDf3b99baFA62c08Cb30E82BC](https://sepolia.etherscan.io/address/0x9C9d17bEE150E4eCDf3b99baFA62c08Cb30E82BC)
  - Deployment and ABI: [EIP712Proxy.json](./deployments/sepolia/EIP712Proxy.json)
- **Indexer**:
  - Contract: [0xaEF4103A04090071165F78D45D83A0C0782c2B2a](https://sepolia.etherscan.io/address/0xaEF4103A04090071165F78D45D83A0C0782c2B2a)
  - Deployment and ABI: [Indexer.json](./deployments/sepolia/Indexer.json)

#### Optimism Sepolia

Version 1.0.2:

- **EAS**:
  - Contract: [0x4200000000000000000000000000000000000021](https://sepolia-optimism.etherscan.io/address/0x4200000000000000000000000000000000000021)
  - Deployment and ABI: [EAS.json](./deployments/optimism-sepolia/EAS.json)
- **SchemaRegistry**:
  - Contract: [0x4200000000000000000000000000000000000020](https://sepolia-optimism.etherscan.io/address/0x4200000000000000000000000000000000000020)
  - Deployment and ABI: [SchemaRegistry.json](./deployments/optimism-sepolia/SchemaRegistry.json)

Version 1.3.0:

- **EIP712Proxy**:
  - Contract: [0x37AC6006646f2e687B7fB379F549Dc7634dF5b84](https://sepolia-optimism.etherscan.io/address/0x37AC6006646f2e687B7fB379F549Dc7634dF5b84)
  - Deployment and ABI: [EIP712Proxy.json](./deployments/optimism-sepolia/EIP712Proxy.json)
- **Indexer**:
  - Contract: [0x97e6822A36E38D4d93C0c810CC2be1C6Fd492b64](https://sepolia-optimism.etherscan.io/address/0x97e6822A36E38D4d93C0c810CC2be1C6Fd492b64)
  - Deployment and ABI: [Indexer.json](./deployments/optimism-sepolia/Indexer.json)

#### Optimism Goerli

Version 1.0.1:

- **EAS**:
  - Contract: [0x4200000000000000000000000000000000000021](https://goerli-optimism.etherscan.io/address/0x4200000000000000000000000000000000000021)
  - Deployment and ABI: [EAS.json](./deployments/optimism-goerli/EAS.json)
- **SchemaRegistry**:
  - Contract: [0x4200000000000000000000000000000000000020](https://goerli-optimism.etherscan.io/address/0x4200000000000000000000000000000000000020)
  - Deployment and ABI: [SchemaRegistry.json](./deployments/optimism-goerli/SchemaRegistry.json)

Version 1.2.0:

- **EIP712Proxy**:
  - Contract: [0x88D1bd62AC014424b987CE5ABf311BD7749e426B](https://goerli-optimism.etherscan.io/address/0x88D1bd62AC014424b987CE5ABf311BD7749e426B)
  - Deployment and ABI: [EIP712Proxy.json](./deployments/optimism-goerli/EIP712Proxy.json)
- **Indexer**:
  - Contract: [0xa42428D1bf904d762adD02b27ADac26d53643782](https://goerli-optimism.etherscan.io/address/0xa42428D1bf904d762adD02b27ADac26d53643782)
  - Deployment and ABI: [Indexer.json](./deployments/optimism-goerli/Indexer.json)

#### Base Sepolia

Version 1.2.0:

- **EAS**:
  - Contract: [0x4200000000000000000000000000000000000021](https://sepolia.basescan.org/address/0x4200000000000000000000000000000000000021)
  - Deployment and ABI: [EAS.json](./deployments/base-sepolia/EAS.json)
- **SchemaRegistry**:
  - Contract: [0x4200000000000000000000000000000000000020](https://sepolia.basescan.org/address/0x4200000000000000000000000000000000000020)
  - Deployment and ABI: [SchemaRegistry.json](./deployments/base-sepolia/SchemaRegistry.json)

Version 1.3.0:

- **EIP712Proxy**:
  - Contract: [0xAd64A04c20dDBbA7cBb0EcAe4823095B4adA5c57](https://sepolia.basescan.org/address/0xAd64A04c20dDBbA7cBb0EcAe4823095B4adA5c57)
  - Deployment and ABI: [EIP712Proxy.json](./deployments/base-sepolia/EIP712Proxy.json)
- **Indexer**:
  - Contract: [0x2C7BCE69D5Ee84EF73CC9286416F68E60F9A61b3](https://sepolia.basescan.org/address/0x2C7BCE69D5Ee84EF73CC9286416F68E60F9A61b3)
  - Deployment and ABI: [Indexer.json](./deployments/base-sepolia/Indexer.json)

#### Base Goerli

Version 1.0.1:

- **EAS**:
  - Contract: [0x4200000000000000000000000000000000000021](https://goerli.basescan.org/address/0x4200000000000000000000000000000000000021)
  - Deployment and ABI: [EAS.json](./deployments/base-goerli/EAS.json)
- **SchemaRegistry**:
  - Contract: [0x4200000000000000000000000000000000000020](https://goerli.basescan.org/address/0x4200000000000000000000000000000000000020)
  - Deployment and ABI: [SchemaRegistry.json](./deployments/base-goerli/SchemaRegistry.json)

Version 1.2.0:

- **EIP712Proxy**:
  - Contract: [0x37AC6006646f2e687B7fB379F549Dc7634dF5b84](https://goerli.basescan.org/address/0x37AC6006646f2e687B7fB379F549Dc7634dF5b84)
  - Deployment and ABI: [EIP712Proxy.json](./deployments/base-goerli/EIP712Proxy.json)
- **Indexer**:
  - Contract: [0xE0893F47009776D6aEC3De8455Cb0ed325Eea74a](https://goerli.basescan.org/address/0xE0893F47009776D6aEC3De8455Cb0ed325Eea74a)
  - Deployment and ABI: [Indexer.json](./deployments/base-goerli/Indexer.json)

#### Arbitrum Goerli

Version 1.1.0:

- **EAS**:
  - Contract: [0xaEF4103A04090071165F78D45D83A0C0782c2B2a](https:/goerli.arbiscan.io/address/0xaEF4103A04090071165F78D45D83A0C0782c2B2a)
  - Deployment and ABI: [EAS.json](./deployments/arbitrum-goerli/EAS.json)
- **SchemaRegistry**:
  - Contract: [0x55D26f9ae0203EF95494AE4C170eD35f4Cf77797](https:/goerli.arbiscan.io/address/0x55D26f9ae0203EF95494AE4C170eD35f4Cf77797)
  - Deployment and ABI: [SchemaRegistry.json](./deployments/arbitrum-goerli/SchemaRegistry.json)

#### Polygon Amoy

Version 1.3.0:

- **EAS**:
  - Contract: [0xb101275a60d8bfb14529C421899aD7CA1Ae5B5Fc](https://amoy.polygonscan.com/address/0xb101275a60d8bfb14529C421899aD7CA1Ae5B5Fc)
  - Deployment and ABI: [EAS.json](./deployments/polygon-amoy/EAS.json)
- **SchemaRegistry**:
  - Contract: [0x23c5701A1BDa89C61d181BD79E5203c730708AE7](https://amoy.polygonscan.com/address/0x23c5701A1BDa89C61d181BD79E5203c730708AE7)
  - Deployment and ABI: [SchemaRegistry.json](./deployments/polygon-amoy/SchemaRegistry.json)
- **EIP712Proxy**:
  - Contract: [0xA0ec8a80a0b8496B9Cf6Ee703bC16ABdC9F4cf2e](https://amoy.polygonscan.com/address/0xA0ec8a80a0b8496B9Cf6Ee703bC16ABdC9F4cf2e)
  - Deployment and ABI: [EIP712Proxy.json](./deployments/polygon-amoy/EIP712Proxy.json)
- **Indexer**:
  - Contract: [0x9F07c0B0E52C36D78Ac8ABfC543c77f83888ac64](https://amoy.polygonscan.com/address/0x9F07c0B0E52C36D78Ac8ABfC543c77f83888ac64)
  - Deployment and ABI: [Indexer.json](./deployments/polygon-amoy/Indexer.json)

#### Scroll Sepolia

Version 1.3.0:

- **EAS**:
  - Contract: [0xaEF4103A04090071165F78D45D83A0C0782c2B2a](https://sepolia.scrollscan.com/address/0xaEF4103A04090071165F78D45D83A0C0782c2B2a)
  - Deployment and ABI: [EAS.json](./deployments/scroll-sepolia/EAS.json)
- **SchemaRegistry**:
  - Contract: [0x55D26f9ae0203EF95494AE4C170eD35f4Cf77797](https://sepolia.scrollscan.com/address/0x55D26f9ae0203EF95494AE4C170eD35f4Cf77797)
  - Deployment and ABI: [SchemaRegistry.json](./deployments/scroll-sepolia/SchemaRegistry.json)
- **EIP712Proxy**:
  - Contract: [0xB3574f76b1720E61FdA98702c7016674CD6Eaa7b](https://sepolia.scrollscan.com/address/0xB3574f76b1720E61FdA98702c7016674CD6Eaa7b)
  - Deployment and ABI: [EIP712Proxy.json](./deployments/scroll-sepolia/EIP712Proxy.json)
- **Indexer**:
  - Contract: [0x7C2cb1eDC328491da52de2a0afc44D3B0Ae7ee17](https://sepolia.scrollscan.com/address/0x7C2cb1eDC328491da52de2a0afc44D3B0Ae7ee17)
  - Deployment and ABI: [Indexer.json](./deployments/scroll-sepolia/Indexer.json)

#### Linea Goerli

Version 1.2.0:

- **EAS**:
  - Contract: [0xaEF4103A04090071165F78D45D83A0C0782c2B2a](https://goerli.lineascan.build/address/0xaEF4103A04090071165F78D45D83A0C0782c2B2a)
  - Deployment and ABI: [EAS.json](./deployments/linea-goerli/EAS.json)
- **SchemaRegistry**:
  - Contract: [0x55D26f9ae0203EF95494AE4C170eD35f4Cf77797](https://goerli.lineascan.build/address/0x55D26f9ae0203EF95494AE4C170eD35f4Cf77797)
  - Deployment and ABI: [SchemaRegistry.json](./deployments/linea-goerli/SchemaRegistry.json)

## Installation

```sh
pnpm add @ethereum-attestation-service/eas-contracts
```

## Testing

Testing the protocol is possible via multiple approaches:

### Unit Tests

You can run the full test suite via:

```sh
pnpm test
```

### Test Coverage

#### Latest Test Coverage Report (2023-10-31)

- 100% Statements 350/350
- 100% Branches 172/172
- 100% Functions 120/120
- 100% Lines 491/491

```sh
----------------------------------|----------|----------|----------|----------|----------------|
File                              |  % Stmts | % Branch |  % Funcs |  % Lines |Uncovered Lines |
----------------------------------|----------|----------|----------|----------|----------------|
 contracts/                       |      100 |      100 |      100 |      100 |                |
  Common.sol                      |      100 |      100 |      100 |      100 |                |
  EAS.sol                         |      100 |      100 |      100 |      100 |                |
  IEAS.sol                        |      100 |      100 |      100 |      100 |                |
  ISchemaRegistry.sol             |      100 |      100 |      100 |      100 |                |
  Indexer.sol                     |      100 |      100 |      100 |      100 |                |
  SchemaRegistry.sol              |      100 |      100 |      100 |      100 |                |
  Semver.sol                      |      100 |      100 |      100 |      100 |                |
 contracts/eip1271/               |      100 |      100 |      100 |      100 |                |
  EIP1271Verifier.sol             |      100 |      100 |      100 |      100 |                |
 contracts/eip712/proxy/          |      100 |      100 |      100 |      100 |                |
  EIP712Proxy.sol                 |      100 |      100 |      100 |      100 |                |
 contracts/eip712/proxy/examples/ |      100 |      100 |      100 |      100 |                |
  PermissionedEIP712Proxy.sol     |      100 |      100 |      100 |      100 |                |
 contracts/resolver/              |      100 |      100 |      100 |      100 |                |
  ISchemaResolver.sol             |      100 |      100 |      100 |      100 |                |
  SchemaResolver.sol              |      100 |      100 |      100 |      100 |                |
 contracts/resolver/examples/     |      100 |      100 |      100 |      100 |                |
  AttestationResolver.sol         |      100 |      100 |      100 |      100 |                |
  AttesterResolver.sol            |      100 |      100 |      100 |      100 |                |
  DataResolver.sol                |      100 |      100 |      100 |      100 |                |
  ExpirationTimeResolver.sol      |      100 |      100 |      100 |      100 |                |
  PayingResolver.sol              |      100 |      100 |      100 |      100 |                |
  RecipientResolver.sol           |      100 |      100 |      100 |      100 |                |
  RevocationResolver.sol          |      100 |      100 |      100 |      100 |                |
  TokenResolver.sol               |      100 |      100 |      100 |      100 |                |
  ValueResolver.sol               |      100 |      100 |      100 |      100 |                |
----------------------------------|----------|----------|----------|----------|----------------|
All files                         |      100 |      100 |      100 |      100 |                |
----------------------------------|----------|----------|----------|----------|----------------|
```

#### Instructions

In order to audit the test coverage of the full test suite, run:

```sh
pnpm test:coverage
```

## Profiling

You can profile the gas costs of all of the user-focused flows via:

```sh
pnpm test:profile
```

## Deploying

The contracts have built-in support for deployments on different chains and mainnet forks. You can deploy the project by:

```sh
pnpm deploy
```

There‚Äôs also a special deployment mode which deploys the protocol to a mainnet fork, with additional goodies. It can be run via:

```sh
pnpm deploy:fork
```

The framework was inspired and adopted from [Bancor V3](https://github.com/bancorprotocol/contracts-v3).

## License

EAS is open source and distributed under the MIT License (see [`LICENSE`](./LICENSE)).



================================================
FILE: docs/quick--start/faqs.md
================================================
---
sidebar_position: 4
---

# FAQs
Explore frequently asked questions about EAS.

## About EAS
<details>
<summary>What is EAS?</summary>
EAS (Ethereum Attestation Service) is an infrastructure tool for making attestations onchain or offchain. As a public good, EAS is completely open-source, permissionless, tokenless, and free to use. It's a new primitive for building more trustful interactions online.
</details>

<details>
<summary>How does EAS work?</summary>
EAS is elegantly simple. It runs on two smart contracts. One to register a schema (which is the data topic of the attestation) and another for making attestations with that schema. This allows you to make a digital signature on structured data.  Just from these two primitives you can unlock so many use cases that seemed out of reach before.
</details>

<details>
<summary>Does EAS also work offchain?</summary>
Absolutely. EAS supports both onchain and offchain attestations, providing flexibility based on the specific needs and use cases. You can learn more about when to use onchain versus offchain attestations in the docs.
</details>

<details>
<summary>What's the difference between onchain and offchain?</summary>
With EAS, you can make attestations onchain or offchain. Onchain requires gas to make the attestation. Offchain requires zero gas. Both options have the authenticity of the digital signature and are immutable. We have a dedicated page to understand the differences in our Core Concepts section.
</details>


<details>
<summary>Where is EAS deployed?</summary>
EAS is deploying where builders are building. You can find EAS deployed on the Ethereum mainnet but also on various Layer 2 solutions and testnets.
</details>

<details>
<summary>Is EAS EVM compatible?</summary>
Yes. EAS can be deployed on any chain that is EVM-based.
</details>

<details>
<summary>What can you build with EAS?</summary>
Anywhere you need more trust in who or what you're interacting with online, attestations can play a role. EAS is versatile. Whether you're looking to verify content, establish reputation systems, build voting systems, or create decentralized identity solutions, and beyond... EAS has got you covered. Our documentation offers a ton of inspiration.

</details>

<details>
<summary>What are the costs associated with using EAS?</summary>
EAS is a free service. However, when making onchain attestations, users will incur gas fees, which vary based on network activity, attestation complexity, and the specific chain used. Offchain attestations, on the other hand, are completely gas-free.

</details>

<details>
<summary>How does EAS make money?</summary>
EAS operates as a public good and doesn't generate revenue from its core services. Its funding sources include donations, grants, and retroactive public goods funding.
</details>

<details>
<summary>Does EAS have a token?</summary>
No. EAS is a tokenless protocol and does not have plans to launch a token. Being a tokenless protocol is critical to our design as to remain credibly neutral. This ensures that no one particular group has a financial advantage over another group. 
</details>

<details>
<summary>Have the EAS contracts been audited?</summary>
Yes. To ensure the utmost security and reliability, EAS contracts have undergone a thorough audit by Spearbit, a reputable third-party firm.
</details>

## Understanding Attestations
<details>
<summary>What exactly is an attestation?</summary>
An attestation is simply a digital signature on some structured data. It allows any entity to say something about anything in an authentic and immutable way. Seems abstract right? Well attestations happen all the time offline. Any time an entity wants or needs to make a verified statement about something, attestations play a role. We just haven't had a way to do this online or onchain. 
</details>

<details>
<summary>What gives an attestation value?</summary>
The value of an attestation comes from the relative reputation of the entity making the claim. It's who makes the attestation that gives it value. The immutability and authenticity of a digital signature is what makes them more secure and verifiable. 

</details>

<details>
<summary>Do attestations always need a recipient?</summary>
Not always. For instance, a social media post is essentially an attestation of a statement made by an individual. Recipients are necessary only when the attestation pertains to a specific entity or address.
</details>

<details>
<summary>Can you edit an attestation after it's been made?</summary>
No. Attestations are immutable to maintain their trustworthiness. If modifications are needed, the issuer would typically revoke the original attestation and create a new one.
</details>

<details>
<summary>How do you keep attestations private?</summary>
EAS offers the flexibility of public and private attestations. Depending on the use case, data can be encrypted, kept off-chain, or selectively disclosed using "Private Data Attestations" and merkle trees.
</details>

<details>
<summary>What happens if someone makes a ton of false attestations?</summary>
False attestations can be challenged or disregarded. The value of an attestation is rooted in the issuer's reputation. Numerous false attestations from a non-credible source would be ignored.
</details>

<details>
<summary>What's the difference between a 'credential' and an 'attestation'?</summary>
A credential is just an attestation from one entity attesting to certain attributes or events about someone else or something. Attestations are more generalized and can be much more than a credential, whereas credentials are not good for all use cases that attestations can solve for. 
</details>

<details>
<summary>Are attestations tokens or NFTs?</summary>
No, attestations differ from tokens or NFTs. They are digital signatures on structured data, signifying a claim or verification. 
</details>

<details>
<summary>Can attestations be revoked?</summary>
Yes. EAS allows the issuer of the attestation to revoke the onchain or offchain attestation. This changes the state of the attestation to "revoked". It does not delete the attestation. The schema can also define if attestations made with that schema are revocable. This allows builders to also create an irrevocable attestation. 
</details>

<details>
<summary>Can attestations be transferable?</summary>
Attestations themselves aren't transferable. However, using the concept of revocation and referenced attestations, a chain of ownership (provenance) and its current state can be established, similar to property title changes.
</details>

<details>
<summary>Why should I use attestations instead of a SBT or NFT?</summary>
While SBTs and NFTs symbolize assets or unique entities, attestations signify claims or verifications. The choice hinges on the need: attestations for trust and verification, and SBTs or NFTs for representing assets. Moreover, SBTs & NFTs lack standardization as every token is its own smart contract address with arbitrary data and structure, posing challenges for interoperability and composability.
</details>

<details>
<summary>Can I batch attestations & revocations?</summary>
Certainly! EAS supports batch attestations and revocations. For a detailed guide, refer to our documentation.
</details>

<details>
<summary>Can someone else pay for the transaction fee for an attestation?</summary>
Yes, through "delegated attestations", you can specify who covers the gas fee, allowing one entity to sign an attestation while another bears the transaction cost.
</details>


## Technical Aspects
<details>
<summary>What is a resolver contract?</summary>
A Resolver Contract is a smart contract linked to a Schema. It ensures that attestations adhere to specific rules or logic before finalization. This feature introduces additional functionalities to schemas, such as user allowlists or conditional NFT minting and much more. Any smart contract logic.
</details>

<details>
<summary>What data is included in each attestation?</summary>
Each attestation has the following struct:
<ul>
<li>uid: The unique identifier of the attestation. </li>
<li>schema: The schema identifier associated with the attestation.</li>
<li>refUID: The reference UID of the attestation, if any.</li>
<li>time: The Unix timestamp when the attestation was created.</li>
<li>expirationTime: The Unix timestamp when the attestation expires (0 for no expiration).</li>
<li>revocationTime: The Unix timestamp when the attestation was revoked, if applicable.</li>
<li>recipient: The Ethereum address of the recipient of the attestation.</li>
<li>attester: The Ethereum address of the attester who created the attestation.</li>
<li>revocable: A boolean indicating whether the attestation is revocable or not.</li>
<li>data: The attestation data in bytes format.</li>
</ul>
</details>

<details>
<summary>How do we coordinate around the right schemas?</summary>
EAS does not presuppose the right schemas for a use case. It's up to the community to coordinate and decide which schemas to use for a particular use case. To help foster this discussion, we have created a dedicated EAS forum at https://forum.easscan.org
</details>


<details>
<summary>Is EAS compatible with zero-knowledge proofs?</summary>
Yes, EAS can be used with zero-knowledge proofs to prove attestations without revealing the underlying data, enhancing privacy.
</details>

<details>
<summary>Where can I store my offchain attestations?</summary>
Off-chain attestations can reside in private databases, decentralized storage systems, or any secure storage medium. The EAS Explorer offers a way for making offchain attestations public, pinning, and indexing the data. Integration with Ceramic and other storage networks is also underway.
</details>

<details>
<summary>How composable is EAS?</summary>
EAS is extremely composable, thanks to the refUID feature, which facilitates the creation of a web of referenced attestations. This provides richer context to attestations. Additionally, the shared use of similar schemas enhances EAS's composability.
</details>

## Community & Support
<details>
<summary>I'm not a developer. How can I benefit from EAS?</summary>
Even if you're not technically inclined, grasping the concept of attestations and their role in enhancing digital trust can be advantageous. As EAS evolves, expect more intuitive applications built on it. Plus, we've crafted no-code tools for non-developers to design schemas and create attestations. All you need is a digital wallet!
</details>

<details>
<summary>What's the best way to get involved?</summary>
Engage with our community channels, contribute to our open-source initiatives, partake in discussions, or simply advocate for EAS.
</details>

<details>
<summary>Where can I find support or ask questions about EAS?</summary>
Our dedicated forum and community channels are your go-to places for any questions, technical assistance, or discussions about EAS.
</details>



================================================
FILE: docs/quick--start/quickstart.md
================================================
---
sidebar_position: 1
---

# Speedrun EAS
Welcome to the EAS Speedrun Guide! Whether you're a seasoned developer or a non-technical builder, this guide will provide you with the fastest path to understanding attestations and kickstarting your journey with EAS.

## Fundamentals
### 1. Understand Attestations
Before diving in, it's crucial to grasp the concept of attestations. Attestations are simply one entity saying something about something. Seems abstract right? That's because it is. Any time an entity is using its reputation to make a claim about something, they're attesting to it.  In a world full of digital interactions, they're the bridge to genuine trust.

:::info 
Attestations are not tokens or NFTs. They're simply digital signatures on structured data.
:::

üìñ **Read More:** [**Learn Why EAS Exists**](/docs/purpose/eas-purpose.md)

üìñ **Read More:** [**What Are Attestations**](/docs/core--concepts/attestations.md)


### 2. How EAS Works
EAS is elegantly simple. It runs on two smart contracts. 

- **SchemaRegistry.sol**: Defines the data structure of the attestation.
- **EAS.sol:** Allows for the creation of attestations using the registered schema.

![Schema & Attestation](./img/schema-attestation-graphic.png)

üìñ **Read More:** [**Get the Core Concepts Down**](/docs/category/core-concepts)

### 2. Get Inspired
Discover the myriad of use cases and applications made possible by EAS. From content verification to reputation systems, the possibilities are endless.

üîó **Explore:** [**See what's possible**](/docs/category/ideas-to-build)

![Use Cases](./img/use-case-examples.png)

## Start Building
### 1. Know the Tools Available to You
These are the most frequently accessed tools to help make your builder experience better.

### Open-Source Code
EAS is transparent and community-driven. Dive into our open-source repositories to see the magic behind the scenes and even contribute.

- **[Contracts](https://github.com/ethereum-attestation-service/eas-contracts):** The contracts are elegantly simple. Check em' out.
- **[SDK](https://github.com/ethereum-attestation-service/eas-sdk):** See the latest version of the SDK Library.
- **[Indexing Service](https://github.com/ethereum-attestation-service/eas-indexing-service):** See how we index attestation data.
- **[Ponder Graph](https://github.com/ethereum-attestation-service/eas-ponder-graph):** See events that happen from attestation data.
- **[Docs Site](https://github.com/ethereum-attestation-service/eas-docs-site):** Contribute to the docs site of EAS.
- **[Contract Example](https://github.com/ethereum-attestation-service/eas-contracts-example):** An example project using the EAS contracts.
- **[Met IRL](https://github.com/ethereum-attestation-service/met-irl):** A sample dapp to see how to use EAS.


### SDK
Our [**Software Development Kit (SDK)**](docs/developer-tools/eas-sdk) provides devs with tools and libraries to seamlessly integrate EAS into their projects. Use the SDK to easily:
- [**Get an attestation**](https://github.com/ethereum-attestation-service/eas-sdk#getting-an-attestation)
- [**Create Onchain Attestations**](https://github.com/ethereum-attestation-service/eas-sdk#creating-on-chain-attestations)
- [**Create Offchain Attestations**](https://github.com/ethereum-attestation-service/eas-sdk#creating-off-chain-attestations)
- [**Create Timestamps for a Single Piece of Data**](https://github.com/ethereum-attestation-service/eas-sdk#revoking-on-chain-attestations)
- [**Revoke Offchain Attestations**](https://github.com/ethereum-attestation-service/eas-sdk#revoking-on-chain-attestations)
- [**Verify Offchain Attestation**](https://github.com/ethereum-attestation-service/eas-sdk#verify-an-off-chain-attestation)
- [**Register a Schema**](https://github.com/ethereum-attestation-service/eas-sdk#registering-a-schema)
- [**Get Schema Information**](https://github.com/ethereum-attestation-service/eas-sdk#getting-schema-information)
and more. 

To install the EAS contracts, run the following command within your project directory

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

<Tabs>
  <TabItem value="yarn" label="Yarn" default>

  ```bash
  yarn add @ethereum-attestation-service/eas-sdk
  ```
  </TabItem>
  <TabItem value="npm" label="npm">

  ```bash
  npm install @ethereum-attestation-service/eas-sdk
  ```

  </TabItem>
  <TabItem value="pnpm" label="pnpm">

  ```bash
  pnpm add @ethereum-attestation-service/eas-sdk
  ```

  </TabItem>
</Tabs>

üìñ Read More: [The SDK Docs](/docs/developer-tools.md/eas-sdk.md)

### GraphQL API
A flexible API that allows for querying and manipulating attestation data, making integration and data retrieval *eas*y. Each chain EAS is deployed on has a related GraphQL endpoint. Just type `/graphql` at the end of the explorer you are on. 

Example for Sepolia:
```bash jsx
https://sepolia.easscan.org/graphql
```

![GraphQL Example Interface](./img/graphql.png)


##